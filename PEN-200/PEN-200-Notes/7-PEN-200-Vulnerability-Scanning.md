# Vulnerability Scanning 
The discovery of vulnerabilities is an integral part of any security assessment. The process of identifying the attack surface of a piece of software, system, or network is called _Vulnerability Scanning_ 

Vulnerability scanners come in many different forms, from individual scripts that identify a single vulnerability to complex commercial solutions that scan for a broad variety
+ Automated vulnerability scanners can be invaluable for penetration testers as they help quickly establish a baseline on the target network before performing a more thorough manual testing analysis to get adequate coverage
+ Common types of vulnerability scanners are web application and network vulnerability scanners

Vulnerability scanning can be extremely helpful during any kind of security assessment. 
+ Configured correctly, vulnerability scanning tools provide a wealth of meaningful data. 
+ It is important for us to understand that a manual review of the results is still required and that scanners can only discover vulnerabilities that they are configured for. 
+ Finally, we should always keep in mind that vulnerability scanning tools can perform actions that could be detrimental to some networks or targets, so we must exercise caution when using them.

## Vulnerability Scanning Theory 

### How Vulnerability Scanners Work 
Every vulnerability scanner has its own customized workflow but the basic process behind vulnerability scanning is implementation independent. The basic process of an automated vulnerability scanner can be described as:
1. Host discovery
2. Port scanning
3. Operating system, service, and version detection
4. Matching the results to a vulnerability database

The **Host Discovery** tells the scanner if the target is up and responding 
+ The scanner then uses various techniques to identify all open ports on the system and detect all remotely accessible services with corresponding versions 
+ Operating system detection will also be done in this step 
+ Based on the gathered information, the vulnerability scanner will query a vulnerability databases to match the found data to vulnerabilities  
	+ Examples of Vulnerability databases are: *National Vulnerability Database* and the *Common Vulnerabilities and Exposures* (**CVE**) program  
+ Vulnerabilities are identified by the CVE system, but it provides no information about the severity of a vulnerability 

**Note**: Most commercial vulnerability scanners also have the functionality to verify found vulnerabilities by attempting to partially or fully exploit them. This can significantly reduce missed vulnerabilities but can impact the stability of the service or system.

#### CVSS
The _Common Vulnerability Scoring System_ (**CVSS**) is a framework for addressing characteristics and severity of vulnerabilities 
+ Each CVE has a CVSS score assigned 
+ The two major versions are CVSSv2 and CVSSv3
	+ Both versions range from 0 to 10 to rate vulnerabilities with different severity labels 

See the range of the base score and associated severity for CVSS v2.0 and v3.0 from the *National Institute of Standards and Technology* (**NIST**):
![[Screenshot 2023-08-04 at 4.51.07 PM.png]]

To obtain a CVSS score, can review the CVE in a vulnerability database, or if there is no CVE assigned, can use a CVSS calculator: https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator
+ In 2019, CVSS v3.1 was released, which clarified and improved the existing version

#### Scanning Errors  
We need to be aware that the results of a vulnerability scan can be incomplete or contain wrongfully detected vulnerabilities
+  _false positive_ occurs when a vulnerability is detected but the target is not actually vulnerable. This can happen through a wrong service and version detection or a configuration that makes the target unexploitable. False positives can also occur when patches or updates are _backported_, meaning that security fixes are applied to an older version of software
+ _False negative_ is another important term. It occurs when a vulnerability is missed by the vulnerability scanner

#### Manual vs Automated Vulnerability Scanning
In a penetration test, we often need to find the right balance between manual and automated vulnerability scanning:
+ A **manual vulnerability** scan will inevitably be very resource intensive and time consuming. When there is a huge amount of data to analyze, we often reach our cognitive limit quickly and overlook vital details. On the other hand, manual vulnerability scanning allows for the *discovery of complex and logical vulnerabilities* that are rather *difficult to discover using any type of automated scanner*
+ **Automated vulnerability** scans are invaluable when working on engagements for a multitude of reasons. First, in nearly all types of assessments, we have time constraints. Therefore, when we have a big enterprise network to scan, we cannot manually review every system. This is especially true when thinking about new or complex vulnerabilities. Second, by using automated scanners, we can *quickly identify easily-detected vulnerabilities and other low-hanging fruit*

We should take the time to explore the inner-workings of every automated tool we plan to use in a security assessment. This will not only assist us in configuring the tool and digesting the results properly, but will help us understand the limitations that must be overcome with manually applied expertise

### Types of Vulnerability Scans 
Will examine _internal_ and _external_ as well as _unauthenticated_ and _authenticated_ vulnerability scans

The location we perform the vulnerability scan from determines the targets visibility 
+ If a client tasks us with an external vulnerability scan, they mean to analyze one or more systems that are accessible from the internet
+ Targets in an external vulnerability scan are often web applications, systems in demilitarized zone (DMZ), and public facing services 

The clients intention is to get an overview of the security status of all systems that are accessible by an **external** attacker 
+ In most cases, we get a list of IP addresses the client wants us to scan, but occasionally, they want us to map al external accessible systems and services by ourselves 
+ While a company should always know which of their systems are publicly accessible, it's not always the case
+ As a result, we will often find externally exposed sensitive systems and services that the company is not aware of

On the other hand, there is the **internal** vulnerability scan where we have direct access to either a part of or the complete internal network of a client
+ When a client tasks us with this kind of vulnerability scan, we either get _VPN_ access, or we perform the scan on-site
+ The intention is to get an overview of the security status of the internal network
+ It is important to analyze which vectors an attacker can use after breaching the perimeter

The next two scan types we will examine are authenticated and unauthenticated vulnerability scans
+ When we perform a vulnerability scan on a system without providing credentials, it is called an **unauthenticated** vulnerability scan
	+ Unauthenticated scans are made to find vulnerabilities in remotely accessible services on a target
	+ Therefore, they map the system with all open ports and provide us with an attack surface by matching the information to vulnerability databases as mentioned before
	+ However, we get no information about local security flaws, such as missing patches, outdated software, or configuration vulnerabilities on the system itself
	+ For example, in an unauthenticated vulnerability scan on a Windows target, we cannot determine if the system is patched against the _HiveNightmare_ vulnerability, which allows a unprivileged user to read sensitive system files
+ Most scanners can be configured to run **authenticated** scans, in which the scanner logs in to the target with a set of valid credentials
	+ In most instances, authenticated scans use a privileged user account to have the best visibility into the target system
	+ The goal of authenticated vulnerability scans is to check for vulnerable packages, missing patches, or configuration vulnerabilities

### Things to consider in a Vulnerability Scan 
In large engagements, we need to configure the vulnerability scanner carefully to get meaningful and relevant results

The first consideration we'll discuss is the *scanning duration*
+ Depending on the scanning type and number of targets, the duration of an automated scan can vary greatly
+ Because external scans over the internet can be time consuming due to the number of hops and intermediate systems on the network route, it's important that we plan accordingly if we have a large list of IP addresses

We also need to discuss *target visibility*
+ While it is easy to input an IP address and start the vulnerability scan, we often have to properly consider our targets
+ It's important to determine if our targets are accessible without the need of any VPNs or permissions in a firewall
+ In most cases, a client providing a list of IP addresses for an external scan isn't a cause for concern
+ But if we are single-handedly determining the attack surface of a client's publicly accessible infrastructure, we need to understand that firewalls and other access restriction mechanisms, which could make systems and services inaccessible, might be in place
	+ For example, an international client has several systems in multiple countries
	+ They restrict access from all IP addresses outside of the country where each system is located
	+ From our location, we are only able to access the systems located in our country while all others are inaccessible to us

Let's also consider *target visibility in an internal engagement*
+ We need to think about our positioning in the network to get meaningful results, especially when we want to scan systems from other subnets
+ Keep in mind that firewalls, _intrusion prevention systems_ (IPS), and intermediate network devices (such as routers), can filter or alter our traffic
+ One example of this is when a vulnerability scanner sends ICMP packets in the Host Discovery step and the intermediate device does not forward them. Hence, the scanner marks the target as offline

 In addition, our scan can be affected by _rate limiting_, which is used to limit the amount of traffic on a network
 + When our scan exceeds thresholds like throughput, packet count, or connection count, the source system of our vulnerability scan can be drastically restricted in the context of networking capabilities
 + When the host discovery and service detection probes are rate limited and therefore slowed down, the vulnerability scanner may miss live hosts or services
 + Most vulnerability scanners can address this by specifying delays, timeouts, and limiting parallel connections

Finally, let's review the *network and system impact of vulnerability scans*
+ A vulnerability scanner produces a lot of network traffic in most configurations, especially if we want to scan multiple targets in a parallel way
+ This can easily render a network unusable
+ To address this, we could reduce the number of parallel scans or the scanning speed
+ An even bigger problem is the potential impact of our vulnerability scan on the stability of a system
+ We need to consider that every vulnerability scan can bring instability to any system or service we scan

## Vulnerability Scanning with Nessus 
Nessus is one of the most popular vulnerability scanners, containing over 67000 CVEs and 168000 plugins.
+ Nessus is available as _Nessus Essentials_ and _Nessus Professional_
	+ We will use the free version
	+ Nessus Essentials, which comes with some restrictions and constraints
		+ For example, we can only scan 16 different IP addresses, and some templates and functions are not available
		+ However, Nessus Essentials will give us insight into how to use the full commercial version and the general concepts discussed in this section will also apply to most commercial scanners

### Installing Nessus 
An internet connection and email address will be necessary to download and activate Nessus
+ The minimum hardware requirements _Tenable_ recommends are 4 CPU cores and 8GB of RAM
+ However, we don't need to meet those requirements for our exercises. 2 CPU cores and 4GB of RAM are sufficient for our needs
+ Nessus is not available in the Kali repositories and needs to be installed manually
+ We can download the current version of Nessus as a 64bit _.deb_ file for Kali from the Tenable website
+ There, we also get the _SHA256_ and _MD5_ checksums for the installer
+ Link for download: https://www.tenable.com/downloads/nessus?loginAttempted=true

Installation on Mac:
+ Users using an Apple system with an ARM-based chip cannot install and use Nessus on a Kali VM as outlined in this Learning Unit. In order to follow along, learners can download the installer for the **macOS - x86_64** platform that includes native support for the Apple M-series chips and install Nessus on the macOS host by following the related installation guide. To access the PEN200 lab environment, you have to connect to the PEN200 VPN on your host system.
+ https://docs.tenable.com/nessus/Content/InstallNessusMacOS.htm
+ **NOTE**: `Nessus-10.5.4-ubuntu1804_aarch64.deb` Works on Kali Linux M1 VM

#### SHA256 Checksum Validation 
After downloading the installer, we'll check the SHA256 checksum to validate 
+ To do this, we click the _Checksum_ button and copy the SHA256 checksum to the clipboard via the copy icon
+ We then **echo** the copied checksum together with the filename of the installer into a file with the name **sha256sum_nessus**
+ Since the button next to the SHA256 checksum only copies the checksum itself, we need to enter the file name manually
+ The resulting **sha256sum_nessus** file needs to be in the same directory as the Nessus installer
+ We will then use <mark style="background: #D2B3FFA6;">sha256sum</mark> with the `-c` parameter to verify the checksum
+ Example usage and output:
```
kali@kali:~$ cd ~/Downloads

kali@kali:~/Downloads$ echo "4987776fef98bb2a72515abc0529e90572778b1d7aeeb1939179ff1f4de1440d Nessus-10.5.0-debian10_amd64.deb" > sha256sum_nessus

kali@kali:~/Downloads$ sha256sum -c sha256sum_nessus
Nessus-10.5.0-debian10_amd64.deb: OK
```
+ The output shows that the checksums match, which means we can install the package
+ If there is an updated version of Nessus, the checksum from the previous listing will be different and needs to be adapted

#### Installation and Start
To **install** the Nessus package, we'll use <mark style="background: #D2B3FFA6;">apt</mark> with the install `option` 
+ Usage: `sudo apt install ./Nessus-10.5.0-debian10_amd64.deb`

After the **installation** is complete, we can start the _nessusd_ service via **systemctl**
+ Usage: `sudo systemctl start nessusd.service`

#### Browser Setup
Once Nessus is running, we can launch a browser and navigate to `https://127.0.0.1:8834` 
+  will be presented with a warning indicating an unknown certificate issuer, which is expected due to the use of a self-signed certificate. To accept and trust the self-signed certificate, we can click on _Advanced..._ and then _Accept the Risk and Continue_

1. After the page loads, we are prompted to configure pre-installation settings. Let's click on _Continue_ to start the installation with the default settings
2. Now, we can select a Nessus product. For the purpose of this Learning Unit, we'll choose _Register for Nessus Essentials_ and click _Continue_
3. Next, we are prompted to request an activation code for Nessus Essentials. We'll provide the required information and click _Register_
4. Once we have registered, the activation code is shown in the next window
5. Next, we'll create a local Nessus user account. We'll choose the username _admin_ with a strong password to protect our vulnerability scan results. We'll use these credentials to log in to the Nessus application
6. Finally, Nessus downloads and compiles all plugins. This can take a significant amount of time to complete
7. After the plugins are downloaded and installed, we have a working instance of Nessus Essentials

### Nessus Components 
Before we start our first vulnerability scan with Nessus, we'll take some time to get familiar with the core components. When we log in for the first time, we find a welcome window that allows us to enter targets. We can close it without entering anything for now

![[Pasted image 20230806212508.png]]
First, let's investigate the tabs in the Nessus dashboard. In the Essentials version of Nessus, we have two tabs called _Scans_ and _Settings_
+ The _Settings_ tab allows us to configure the application
	+ For example, we can enter information for a _SMTP server_ to get scan results via email
	+ The advanced menu allows us to configure global settings ranging from user interface, scan and log behavior, to security and performance related options
+ Shown above, the _About_ menu lists basic information for Nessus, our license, and how many hosts we have left
	+ For further information on how we can customize and configure Nessus, we can consult the Nessus documentation

![[Pasted image 20230806212528.png]]
Next, let's examine policies and templates, we'll click on the _Scan_ tab then on _Policies_
+ A policy is a set of predefined configuration options in the context of a Nessus scan. When we save a policy, we can use it as a template for a new scan
+ Let's now click on _Scan Templates_ (Seen Above), Nessus already provides a broad variety of scanning templates for us to use. These templates are grouped into the three categories _Discovery_, _Vulnerabilities_, and _Compliance_

The _Compliance_ category is only available in the enterprise version as well as the _Mobile Device Scan_ template
+ The only template in the _Discovery_ category is _Host Discovery_, which can be used to create a list of live hosts and their open ports
+ The _Vulnerabilities_ category consists of templates for critical vulnerabilities or vulnerability groups e.g. _PrintNightmare_ or _Zerologon_ as well as templates for common scanning areas e.g. _Web Application Tests_ or _Malware Scans_

Nessus also provides three general vulnerability scanning templates:
1. The _Basic Network Scan_ performs a full scan with the majority of settings predefined. It will detect a broad variety of vulnerabilities and is therefore the recommended scanning template by Nessus. We also have the option to customize these settings and recommendations.
2. The _Advanced Scan_ is a template without any predefined settings. We can use this when we want to fully customize our vulnerability scan or if we have specific needs.
3. The last general scanning template, _Advanced Dynamic Scan_, also comes without any predefined settings or recommendations. The biggest difference between the two templates is that in the Advanced Dynamic Scan, we don't need to select plugins manually. The template allows us to configure a _dynamic plugin filter_ instead.

Nessus Plugins are programs written in the _Nessus Attack Scripting Language_ (NASL) that contain the information and the algorithm to detect vulnerabilities. Each plugin is assigned to a _plugin family_, which covers different use cases. We will work with the Advanced Dynamic Scan template and plugins in the last section of this Learning Unit.

### Performing a Vulnerability Scan 
To begin, will click the *New Scan* button on the dashboard in the *Scans* tab 
+ Nessus provides a list of the different templates. For a simple start, can use _Basic Network Scan_, which we can launch by clicking on it
+ This will present the scan configuration settings screen containing the _BASIC_, _DISCOVERY_, _ASSESSMENT_, _REPORT_, and _ADVANCED_ settings:
![[Pasted image 20230806213802.png]]

The default screen is the _General_ settings page with the two required arguments: a **name** for our scan and a **list of targets**
+ Nessus supports multiple target specifications: including a single IP address, an IP range, and a comma-delimited _Fully-Qualified Domain Name_ (FQDN), or an IP address list

For example, we will scan the following machines: POULTRY, JENKINS, WK01, and SAMBA. We will enter "Basic Vulnerability Scan" into the _Name_ field and the IP addresses of the machines into the _Targets_ field:
![[Pasted image 20230806213944.png]]
+ Since we chose the Basic Network Scan template, Nessus has already configured most of the settings for us
+ However, the default configuration might not be exactly what we need. Depending on the scanning type, the environment, time constraints, and the targets, we may need to adapt the settings to fit our needs

In the default settings of this template, Nessus scans a list of common ports. For this demonstration, we only want to scan ports 80 and 443. To do this, let's click on the _Discovery_ settings and select _Custom_ in the dropdown menu:
![[Pasted image 20230806214039.png]]
+ After we click on _Custom_, additional configuration menus appear under the _DISCOVERY_ menu
+ We can now customize the Basic Network Scan template the same way as the Advanced Scan template in the context of the _DISCOVERY_ menu
+ Within the _Port Scanning_ section, we will set the _Port scan range_ to "80,443"
+ Additionally, we'll enable the option _Consider unscanned ports as closed_ so that Nessus treats other ports as closed, since we are only interested in ports 80 and 443:
![[Pasted image 20230806214123.png]]

In this demonstration, we've customized the Basic Network Scan template to only scan two specific TCP ports
+ But even in the default settings of this template, Nessus does not scan UDP ports
+ If we want to activate UDP port scanning, we need to manually configure it
+ We may miss crucial information on UDP services when it's disabled during assessments, but we need to understand that activating UDP port scanning will *vastly increase* the scan duration
+ Due to the nature of UDP, it is not often possible to tell the difference between an open and a filtered port

To save time and scan the targets more quietly, we will turn off _Host Discovery_ because we know the hosts are available
+ We do this by navigating to _Discovery_ > _Host Discovery_ where we toggle _Ping the remote host_ to _Off_:
![[Pasted image 20230806214231.png]]

During the configuration of the scan definition, we did not configure any credentials, which implies that this scan will run **unauthenticated**

We also didn't change the default settings of the _ASSESSMENT_ menu in the Basic Network Scan template
+ This means the brute forcing of user credentials will not be done
+ Even though brute forcing is disabled, our scan creates a lot of network traffic and because we're scanning multiple hosts, will be highly noticeable

Now that we have a basic understanding of how we can customize templates to fit our needs, we can launch our first scan. We can do this by clicking on the arrow next to _Save_ and selecting _Launch_:
![[Pasted image 20230806214323.png]]

Initially, the scan will have a status of _Running_ in the Nessus dashboard under _My Scans_:
![[Pasted image 20230806214342.png]]

Below shows the running scan and provides the options to stop or pause it. Once the scan is finished, the status will change to _Completed_:
![[Pasted image 20230806214350.png]]

### Analyzing the Results 
In this section we will analyze the results of our first vulnerability scan. Due to the continuous updates of Nessus and its plugins, the scan results can differ slightly. We can click on the scan in the _My Scans_ list to get to the results dashboard:
![[Pasted image 20230806224816.png]]
+ The initial view displays the _Hosts_ page, which lists all scanned hosts and provides a visual representation of the vulnerability data
+ This allows us to identify important findings in one glance and gives us an overview of the security status of each system
+ On the bottom right, Nessus displays a visual representation of the distribution of all targets' vulnerability information
+ Above it, we can find general information about the vulnerability scan
+ **Note**: Nessus plugins are frequently updated. Therefore, the findings, groupings, and information presented in this Learning Unit may differ slightly from the results of your vulnerability scans

To get the list of findings from a specific host, we can click on a list entry. This shows us the list of vulnerabilities from the selected host. Let's click on the entry for _192.168.50.124_:
![[Pasted image 20230806225020.png]]
+ The _Severity_ column gives us a quick indicator if this is a critical finding or not
+ Can also shows us that there are three findings with the _MIXED_ severity
	+ Nessus uses this severity when it groups findings
+ The _Count_ column shows us how many findings the corresponding group contains
+ We can click on a grouped finding to display a list of all findings in this group
+ Let's click on _Apache Httpd (Multiple Issues)_, which is listed as _Web Servers_ under the _Family_ column

![[Pasted image 20230806225142.png]]
It shows us information on the findings, which were previously grouped. We can get more information by clicking on a finding. 
+ Let's click on _Apache 2.4.49 < 2.4.51 Path Traversal Vulnerability_

![[Pasted image 20230806225240.png]]
Each finding contains a huge amount of information about the vulnerability itself, as well as the plugin that detected it
+ Furthermore, we get a lot of information about the associated risk, status of exploits, and other references

Analyzing the findings of a single target provides us with a lot of detailed information. However, we often want to get an overview of the most important vulnerabilities of all targets. To achieve this, Nessus provides a handy feature to get a prioritized overview of vulnerabilities named _VPR Top Threats_, which utilizes the _Vulnerability Priority Rating_ (VPR).
+ The findings in the VPR list consist of the top ten vulnerabilities of the scan

![[Pasted image 20230806225503.png]]
+ In our example, the list only contains six vulnerabilities as Nessus didn't find more with our configuration
+ **Note**: Depending on the version of Nessus, the tab _VPR Top Threats_ may be missing while following along. However, each vulnerability finding still contains the Vulnerability Priority Rating

The next page we'll examine is _Remediations_
+ If Nessus detects a vulnerability, the plugins often contain a remediation strategy, or information on how to mitigate the vulnerability
+ In the case of the Apache vulnerabilities, we get the following information:
![[Pasted image 20230806225621.png]]

The last report page is _History_. This page lists all vulnerability scans with this configuration. We can use it to review or compare results of previous scans

We now have an understanding of how to view the results of a Nessus scan. Next, let's create a **PDF** report of our vulnerability scan
+ We can do this by using the functions in the _Report_ dashboard
+ Apart from the creation of a report, the functions also cover the change of the scan configuration, launch of another scan, or exporting data
+ We can also configure an _Audit Trail_, which allows us to analyze why a specific plugin behaved in a certain way. It can be used to reduce the number of false negatives

Let's create a PDF report for our first vulnerability scan by clicking _Report_
+ Once we click on the button, a new window allows us to use different report templates. Each template generates the report with a different structure, focus, and content
+ For this example, we'll use the _Detailed Vulnerabilities By Host_ template, which presents detailed findings grouped by each host. We'll then select _PDF_ as format and click _Generate Report_:
![[Pasted image 20230806225806.png]]
+ After this, we can download or open the PDF report
+ We could also use the _Complete List of Vulnerabilities by Host_ template to create a summary of the vulnerabilities instead of including detailed information

Nessus also has the capability to build a _Sitemap_ of a target web server
+ A Sitemap provides information about the content of a web server (e.g. pages)
+ Nessus builds it by crawling through links it identifies on pages
+ To configure Nessus to build a Sitemap, click on the _Assessment_ settings in the scan configuration and select _Custom_ in the dropdown menu. Next, click on _Web Applications_ and activate _Scan web applications_
+ Once it is finished, review the results and analyze the finding _Web Application Sitemap_
	+ Can look for it in specific host vulnerabilities, or just search for all of them in the vulnerabilities tab filter 

### Performing an Authenticated Vulnerability Scan
We will perform an authenticated vulnerability scan by providing credentials to Nessus
+ As we discussed previously, authenticated scans produce more detailed information and reduce the number of false positives
+ To demonstrate this, we will use an authenticated vulnerability scan against the target _DESKTOP_
+ We need to consider that an authenticated scan not only creates a lot of traffic on the network, but also a huge amount of noise on the system itself, such as log entries and AV notifications.

Even though all Nessus templates accept user credentials, we'll use the _Credentialed Patch Audit_ scan template, which comes preconfigured to execute local security checks against the target
+ The difference between this and the Basic Network Scan template with provided credentials, is that the Credentialed Patch Audit scan only uses local security checks and will not do a regular vulnerability check from an external perspective
+ The Credentialed Patch Audit template will not only scan for missing operating system patches, but also for outdated applications, which may be vulnerable to _privilege escalation attacks_
![[Pasted image 20230807094630.png]]

After providing a name for the scan and setting the target, will click on the _Credentials_ tab and select _SSH_ in the _Host_ category
+ On the _Authentication method_ dropdown, will enter username and password
+ Can select _sudo_ for the _Elevate privileges with_ option and enter sudo user credentials:
![[Pasted image 20230807094828.png]]

While we will use the SSH configuration for this example, there are several other authentication mechanisms available
+ To get a list of all available mechanisms, we can click the _Categories_ dropdown menu and select _All_. We can consult the _Tenable Documentation_
+ For Linux and macOS targets, SSH is used
+ While we can also use SSH on Windows, in most cases, we will use _Server Message Block_ (SMB) and _Windows Management Instrumentation_ (WMI) to perform authenticated vulnerability scans against Windows targets
+ Both methods allow us to use local or domain accounts and different authentication options

To get meaningful results in an authenticated vulnerability scan, we need to ensure that our target system is configured correctly
+ Depending on the authentication method we want to use, we need to make sure that there is no firewall blocking connections from our scanner
+ Furthermore, we often find _antivirus_ (AV) programs installed on both Linux and Windows targets
+ AV may flag the vulnerability scan as malicious and therefore, terminate our connection or render the results useless
+ Depending on the AV program, we can add an _exception_ for the authenticated scan or temporarily disable it 

Another Windows security technology we need to consider is _User Account Control_ (UAC)
+ UAC is a security feature for Windows that allows users to use standard privileges instead of administrator privileges
+ An administrative user will run most applications and commands in standard privileges and receive administrator privileges only when needed
+ Due to the nature of UAC, it can also interfere with our scan
+ We can configure UAC to allow Nessus or temporarily disable it 
+ Should consult the _Tenable Documentation_, especially for Windows targets, before we start our first authenticated scan

In this example, our scan target is a Linux system without AV
+ Therefore, we can click the arrow next to _Save_ and launch the scan
+ After the scan has finished, we can review the results
+ In the _Vulnerabilities_ page, we get a list of the findings for the authenticated scan
+ In the last section, we had already grouped findings with the _MIXED_ severity. For our authenticated scan, let's disable the grouping of findings by clicking on the wheel and selecting _Disable Groups_:
![[Pasted image 20230807095329.png]]
+ They are now listed separately:
![[Pasted image 20230807095354.png]]

We get a list of vulnerabilities from the _Ubuntu Local Security Checks_ plugin family
+ Plugins grouped into plugin families check for vulnerabilities in the same context
+ For example, there are separate plugin families for checking vulnerabilities in databases, firewalls, or web servers
+ The Ubuntu Local Security Checks plugin family contains a multitude of plugins that check for local vulnerabilities and missing patches for Ubuntu

The _Name_ column provides us with the vulnerable Ubuntu versions and a brief description as well as the patch number for the vulnerabilities:
![[Pasted image 20230807095507.png]]
+ The list also contains vulnerability data of locally exposed applications such as _Firefox_ or _cURL_

### Working with Nessus Plugins 
By default, Nessus will enable a number of plugins behind-the-scenes, when running a default template
+ While this is certainly useful in many scenarios, we can also fine-tune our options to quickly run a single plugin
+ We can use this feature to validate a previous finding or to quickly discover all the targets in an environment that are at risk to a specific vulnerability

For this example, we will set a plugin filter to identify if the _DESKTOP_ machine is vulnerable to _CVE-2021-3156_
+ This is a locally exploitable vulnerability that allows an unprivileged user to elevate privileges to root

To leverage the dynamic plugin filter, will once again do a *New Scan*
![[Pasted image 20230808114518.png]]

This time, we will use the Advanced Dynamic Scan template
+ This template allows us to use a dynamic plugin filter instead of manually enabling or disabling plugins:
![[Pasted image 20230808114555.png]]

Will configure the needed `Basic > General` information, including the name and target 
+ Will provide SSH and sudo credentials used in the last example, meaning we'll also be conducting an *authenticated scan*
+ Can select the plugins we want to use in our vulnerability scan
+ To do so, let's click on the _Dynamic Plugins_ tab 
	+ In the left dropdown menu, we'll select _CVE_ to filter for a specific CVE
	+ In the middle dropdown menu, we can choose from different filter arguments to specify the matching behavior
	+ On the right dropdown menu, we can specify a CVE number
	+ After entering "CVE-2021-3156", we can click on _Preview Plugins_, which may take a few minutes:
![[Pasted image 20230808114811.png]]

Once _Preview Plugins_ is finished running, we get a list of found plugin families that cover this particular CVE:
![[Pasted image 20230808114829.png]]
+ One very handy feature of the dynamic plugin filter is the ability to combine multiple filters
+ In this example, we know that the target is an Ubuntu Linux system and we can therefore use a second filter to specify the related plugin family
+ Add a new filter by clicking on the _plus_ button next to the first filter
+ A new plugin filter appears. To restrict the plugin family to specific checks for Ubuntu, let's select _Plugin Family_ on the left dropdown and _Ubuntu Local Security Checks_ on the right dropdown:
![[Pasted image 20230808114912.png]]

We can then click on _Preview Plugins_ again to list the plugins determined by our filters
+ After it completes, let's click on the dropdown and choose _Ubuntu Local Security Checks_
+ Nessus displays information about the plugin, including affected Ubuntu versions, short description, and patch number, as well as the Plugin ID:
![[Pasted image 20230808114948.png]]

We can get more information by clicking on the plugin. Below shows the detailed information of the specified plugin: 
![[Pasted image 20230808115016.png]]

After closing this window, we can launch the vulnerability scan as we did before
+ Once the scan is finished, cant review the results by clicking on the _Vulnerabilities_ tab:
![[Pasted image 20230808115100.png]]
+ The output lists one finding with a _HIGH_ severity, which was found by the plugin we specified with our dynamic plugin filter
+ See detailed information of the finding, confirming that the target is in fact vulnerable to CVE-2021-3156:
![[Pasted image 20230808115141.png]]

The plugin output also contains information stating that Nessus only used the reported version number of the affected application and that it did not try to confirm the vulnerability by exploiting it in any way. In an assessment, we *should verify* these kinds of results to check if it is indeed an exploitable vulnerability

## Vulnerability Scanning with Nmap

### NSE Vulnerability Scripts 
NSE scripts extend the basic functionality of Nmap to do a variety of networking tasks
+ These tasks are grouped into categories surrounding:
	+ Vulnerability Detection 
	+ Brute Forcing 
	+ Network Discovery 
+ These scripts can also improve version detection, and information gathering capabilities 
+ An NSE script can also fall into more than one category 
	+ Example: Can be categorized as a *safe* and *vuln*, or *intrusive* and *vuln* 
		+ Scripts categorized as "safe" have no potential impact to stability, while scripts in the "intrusive" category might crash a target service or system
		+ Should avoid stability issues by checking how scripts are categorized, and never running NSE scripts without understanding the implication 
+ Can determine the categories of a script by browsing the **NSE Documentation**, or locally in the NSE scripts directory
	+ NSE Scripts reference: https://nmap.org/nsedoc/scripts/
	+ NSE Scripts libraries: https://nmap.org/nsedoc/lib/

The **vuln** category is especially useful for vulnerability scanning 
+ On Kali, the NSE scripts can be found in the `/usr/share/nmap/scripts/` directory with the `.nse` filetype
+ This directory also contains the **script.db** file, which serves as an index to all currently available NSE scripts
+ Can get a list of scripts in the **vuln** category with the following command:
```
cd /usr/share/nmap/scripts/
cat script.db  | grep "\"vuln\""
```
+ Example output:
```
Entry { filename = "afp-path-vuln.nse", categories = { "exploit", "intrusive", "vuln", } }
Entry { filename = "broadcast-avahi-dos.nse", categories = { "broadcast", "dos", "intrusive", "vuln", } }
Entry { filename = "clamav-exec.nse", categories = { "exploit", "vuln", } }
Entry { filename = "distcc-cve2004-2687.nse", categories = { "exploit", "intrusive", "vuln", } }
Entry { filename = "dns-update.nse", categories = { "intrusive", "vuln", } }
...
```
+ Each entry has a *file name* and *categories*. The file name represents the name of the NSE script in the NSE directory

Nmap `--script` parameter is very important for this usage 
+ This parameter is responsible for determining which NSE scripts get executed in a scan
+ The arguments for this parameter can be a category, a Boolean expression, a comma-separated list of categories, the full or wildcard-specified name of a NSE script in **script.db**, or an absolute path to a specific script

Some of the standard NSE scripts are quite outdated, Fortunately, the _vulners_ script was integrated, which provides current vulnerability information about detected service versions from the _Vulners Vulnerability Database_
+ The script itself has the categories _safe_, _vuln_, and _external_
+ Nmap scan using all of the NSE scripts from the _vuln_ category:
```
sudo nmap -sV -p <PORT> --script "vuln" <IP>
```
+ The command we'll use contains the previously mentioned **--script** parameter with the **vuln** argument, which specifies all of the scripts with this category. Furthermore, we'll provide **-sV** to activate the Nmap's service detection capabilities. Finally, can use **-p** optionally to specify desired ports 
+ Example usage: `sudo nmap -sV -p 443 --script "vuln" 192.168.50.124`
	+ Example output:
```
Starting Nmap 7.92 ( https://nmap.org )
...
PORT    STATE SERVICE VERSION
443/tcp open  http    Apache httpd 2.4.49 ((Unix))
...
| vulners: 
|   cpe:/a:apache:http_server:2.4.49:
...
        https://vulners.com/githubexploit/DF57E8F1-FE21-5EB9-8FC7-5F2EA267B09D	*EXPLOIT*
|     	CVE-2021-41773	4.3	https://vulners.com/cve/CVE-2021-41773
...
|_http-server-header: Apache/2.4.49 (Unix)
MAC Address: 00:0C:29:C7:81:EA (VMware)
```
+ Nmap detected the _Apache_ service with the version 2.4.49 and tried all of the NSE scripts from the _vuln_ category
+ Most of the output comes from the `vulners` script, which uses the information from the detected service and version to provide related vulnerability data
+ The `vulners` script not only shows us information about the CVEs found but also the CVSS scores and links for additional information
+ For example, Listing 5 shows that Nmap, in combination with the `vulners` script, detected that the target is vulnerable to _CVE-2021-41773_
+ Another useful feature of the `vulners` script is that it also lists _Proof of Concepts_ for the found vulnerabilities, which are marked with "*EXPLOIT*"
	+ However, without a successful service detection, the `vulners` script will not provide any results

### Working with NSE Scripts 
While the `vulners` script provides an overview of all CVEs mapped to the detected version, we sometimes want to check for a specific CVE
+ This is especially helpful when we want to scan a network for the existence of a vulnerability
+ If we do this with the `vulners` script, we would need to review an enormous amount of information
+ For most modern vulnerabilities, we need to integrate dedicated NSE scripts manually

Will learn to do this with the example *CVE-2021-41773*
+ In order to find a suitable NSE script, we can use a search engine to find the CVE number plus NSE (**CVE-2021-41773 nse**)
+ One of the first search results is a link to a _GitHub_ page: https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse
	+ Provides a script to check for this vulnerability
+ Can download this script and save it as `/usr/share/nmap/scripts/http-vuln-cve2021-41773.nse` to comply with the naming syntax of the other NSE scripts
	+ Before we can use the script, we'll need to update **script.db** with `--script-updatedb`, see example usage:
```
kali@kali:~$ sudo cp /home/kali/Downloads/http-vuln-cve-2021-41773.nse /usr/share/nmap/scripts/http-vuln-cve2021-41773.nse

kali@kali:~$ sudo nmap --script-updatedb
[sudo] password for kali: 
Starting Nmap 7.92 ( https://nmap.org )
NSE: Updating rule database.
NSE: Script Database updated successfully.
Nmap done: 0 IP addresses (0 hosts up) scanned in 0.54 seconds
```

To use the NSE script, we'll provide the name of the script, target information, and port number. We'll also enable service detection
+ Example usage: `sudo nmap -sV -p 443 --script "http-vuln-cve2021-41773" 192.168.50.124`
	+ Example output;
```
Starting Nmap 7.92 ( https://nmap.org )
Host is up (0.00069s latency).

PORT    STATE SERVICE VERSION
443/tcp open  http    Apache httpd 2.4.49 ((Unix))
| http-vuln-cve2021-41773:
|   VULNERABLE:
|   Path traversal and file disclosure vulnerability in Apache HTTP Server 2.4.49
|     State: VULNERABLE
|               A flaw was found in a change made to path normalization in Apache HTTP Server 2.4.49. An attacker could use a path traversal attack to map URLs to files outside the expected document root. If files outside of the document root are not protected by "require all denied" these requests can succeed. Additionally this flaw could leak the source of interpreted files like CGI scripts. This issue is known to be exploited in the wild. This issue only affects Apache 2.4.49 and not earlier versions.
|           
|     Disclosure date: 2021-10-05
|     Check results:
|       
|         Verify arbitrary file read: https://192.168.50.124:443/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
...
Nmap done: 1 IP address (1 host up) scanned in 6.86 seconds
```
+ The output indicates that the target is vulnerable to CVE-2021-41773 and provides us with additional background information

While Nmap is not a vulnerability scanner in the traditional sense, we found that the NSE is a powerful feature that allows us to do *lightweight vulnerability scanning*
+ In a penetration test, we can use Nmap when there isn't a full-fledged vulnerability scanner available or when we want to verify findings from other tools

However, we have the same factors to consider as with any other vulnerability scanner
+ The NSE script categories can provide useful information, such as if a script is intrusive or safe, but we also need to keep in mind that an NSE script may contain malicious code that gives an attacker full access to our system
+ For that reason, we always need to verify that the NSE script not only provides the needed functionality, but is also safe

